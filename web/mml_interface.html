<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMS MML ç®¡ç†ç»ˆç«¯</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            overflow: hidden;
        }

        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        #main-area {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* æ‹–åŠ¨åˆ†éš”æ¡æ ·å¼ */
        .resizer {
            background: #3e3e42;
            cursor: col-resize;
            width: 4px;
            position: relative;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .resizer:hover {
            background: #667eea;
        }
        
        .resizer:hover .toggle-panel-btn {
            opacity: 1;
        }
        
        .resizer-horizontal {
            cursor: row-resize;
            height: 4px;
            width: 100%;
        }

        /* å¤´éƒ¨ */
        #header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            height: 50px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
        }

        #header h1 {
            font-size: 20px;
            font-weight: 600;
            letter-spacing: 1px;
        }

        #header .status {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .username {
            color: #4ec9b0;
            font-weight: 500;
        }

        .logout-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .logout-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* å·¦ä¾§å‘½ä»¤æ ‘ */
        #command-tree-panel {
            background: #252526;
            overflow-y: auto;
            overflow-x: hidden;
            width: 280px;
            min-width: 200px;
            max-width: 600px;
            transition: width 0.3s ease, min-width 0.3s ease;
        }
        
        #command-tree-panel.collapsed {
            display: none;
        }

        .tree-header {
            padding: 15px;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .tree-header h3 {
            font-size: 14px;
            color: #cccccc;
            margin-bottom: 10px;
        }

        #tree-search {
            width: 100%;
            padding: 8px;
            background: #3c3c3c;
            border: 1px solid #555;
            border-radius: 3px;
            color: #d4d4d4;
            font-size: 12px;
        }

        #tree-search:focus {
            outline: none;
            border-color: #007acc;
        }

        .tree-category {
            margin: 5px 0;
        }

        .category-header {
            padding: 10px 15px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }

        .category-header:hover {
            background: #2d2d30;
        }

        .category-icon {
            font-size: 16px;
        }

        .category-name {
            font-size: 13px;
            font-weight: 500;
        }

        .category-toggle {
            margin-left: auto;
            transition: transform 0.2s;
        }

        .category-toggle.expanded {
            transform: rotate(90deg);
        }

        .category-commands {
            display: none;
            background: #1e1e1e;
        }

        .category-commands.show {
            display: block;
        }

        .command-item {
            padding: 8px 15px 8px 40px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .command-item:hover {
            background: #094771;
        }

        .command-item.selected {
            background: #0e639c;
        }

        /* ä¸­é—´é¢æ¿ */
        #middle-panel {
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            min-height: 0;
            flex: 1;
            min-width: 400px;
        }

        /* è¾“å‡ºåŒºåŸŸ */
        #output-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            min-height: 0;
        }
        
        /* è¾“å‡ºé¡µç­¾ */
        #output-tabs {
            display: flex;
            gap: 2px;
            background: #1e1e1e;
            padding: 5px 15px 0;
            border-bottom: 1px solid #3e3e42;
            flex-shrink: 0;
        }
        
        .output-tab {
            background: #2d2d30;
            color: #969696;
            border: none;
            padding: 8px 20px;
            cursor: pointer;
            font-size: 13px;
            border-radius: 4px 4px 0 0;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }
        
        .output-tab:hover {
            background: #3c3c3c;
            color: #cccccc;
        }
        
        .output-tab.active {
            background: #1e1e1e;
            color: #4ec9b0;
            border-bottom-color: #4ec9b0;
        }
        
        /* è¾“å‡ºå†…å®¹åŒºåŸŸ */
        #output-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 0;
        }
        
        /* å†å²è®°å½•åŒºåŸŸ */
        /* SIPæ¶ˆæ¯è·Ÿè¸ªé¢æ¿ */
        #sip-messages-content {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            background: #1e1e1e;
        }
        #media-endpoints-content {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            background: #1e1e1e;
        }

        .sip-messages-controls {
            flex-shrink: 0;
            padding: 15px;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
        }

        .sip-messages-control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sip-messages-btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 6px 15px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .sip-messages-btn:hover {
            background: #1177bb;
        }
        
        .sip-messages-btn.paused {
            background: #d32f2f;
        }
        
        .sip-messages-btn.paused:hover {
            background: #f44336;
        }

        #sip-messages-stats {
            font-size: 12px;
            color: #4ec9b0;
            margin-left: auto;
        }

        .media-endpoints-diagnosis {
            padding: 12px 15px;
            background: #252526;
            border-bottom: 1px solid #3e3e42;
            font-size: 13px;
            color: #4ec9b0;
        }
        .media-endpoints-diagnosis.warn { color: #dcdcaa; }
        .media-endpoints-diagnosis.err { color: #f48771; }
        .media-endpoints-sessions {
            flex: 1;
            overflow: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .media-session-card {
            background: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 6px;
            padding: 12px 15px;
            font-size: 12px;
        }
        .media-session-card h4 {
            color: #4ec9b0;
            margin-bottom: 8px;
            font-size: 13px;
        }
        .media-session-card .diagnosis { color: #dcdcaa; margin-top: 8px; }
        .media-session-card .diagnosis.ok { color: #4ec9b0; }
        .media-session-card table.media-ports { width: 100%; border-collapse: collapse; margin-top: 6px; }
        .media-session-card table.media-ports th, .media-session-card table.media-ports td { padding: 4px 8px; text-align: left; border-bottom: 1px solid #3e3e42; }
        .media-session-card table.media-ports th { color: #969696; }
        .media-endpoints-sessions .empty { color: #969696; text-align: center; padding: 40px; }
        
        /* åª’ä½“ç›‘å¬æŒ‰é’® */
        .monitor-buttons {
            margin-top: 10px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .monitor-btn {
            padding: 6px 12px;
            background: #2d2d2d;
            border: 1px solid #3e3e3e;
            color: #d4d4d4;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.2s;
        }
        .monitor-btn:hover {
            background: #3e3e3e;
            border-color: #569cd6;
        }
        .monitor-btn.active {
            background: #007acc;
            border-color: #569cd6;
            color: #fff;
        }
        
        /* åª’ä½“ç›‘å¬çª—å£ */
        .media-monitor-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            max-width: 90vw;
            max-height: 80vh;
            background: #1e1e1e;
            border: 2px solid #3e3e3e;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 10000;
            display: none;
            flex-direction: column;
        }
        .media-monitor-window.active {
            display: flex;
        }
        .media-monitor-header {
            padding: 12px 16px;
            background: #252526;
            border-bottom: 1px solid #3e3e3e;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 8px 8px 0 0;
        }
        .media-monitor-title {
            font-weight: bold;
            color: #d4d4d4;
        }
        .media-monitor-close {
            background: none;
            border: none;
            color: #858585;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            line-height: 24px;
        }
        .media-monitor-close:hover {
            color: #fff;
        }
        .media-monitor-content {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }
        .media-monitor-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }
        .media-monitor-stat-item {
            background: #252526;
            padding: 12px;
            border-radius: 4px;
            border: 1px solid #3e3e3e;
        }
        .media-monitor-stat-label {
            font-size: 12px;
            color: #858585;
            margin-bottom: 4px;
        }
        .media-monitor-stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4ec9b0;
        }
        .media-monitor-chart {
            background: #252526;
            padding: 12px;
            border-radius: 4px;
            border: 1px solid #3e3e3e;
            height: 200px;
            margin-top: 16px;
        }
        .media-monitor-status {
            padding: 8px 12px;
            background: #2d2d2d;
            border-radius: 4px;
            margin-top: 12px;
            font-size: 12px;
            color: #858585;
        }
        .media-monitor-status.connected {
            color: #4ec9b0;
        }
        .media-monitor-status.error {
            color: #f48771;
        }
        .media-monitor-panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 12px;
        }
        .media-monitor-panel {
            background: #252526;
            border: 1px solid #3e3e3e;
            border-radius: 6px;
            overflow: hidden;
        }
        .media-monitor-panel-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            background: #2d2d2d;
            font-size: 12px;
        }
        .media-monitor-panel-title { color: #d4d4d4; }
        .media-monitor-mute { font-size: 11px; color: #858585; cursor: pointer; margin: 0; display: flex; align-items: center; gap: 4px; }
        .media-monitor-mute-cb { cursor: pointer; }
        .media-monitor-panel-body {
            padding: 8px;
            min-height: 48px;
            font-size: 12px;
            color: #858585;
        }
        .media-monitor-video-wrap {
            padding: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .media-monitor-canvas {
            max-width: 100%;
            max-height: 180px;
            background: #1e1e1e;
            border-radius: 4px;
        }
        .media-monitor-panel-info { font-size: 11px; color: #858585; margin-top: 4px; word-break: break-all; white-space: pre-wrap; max-height: 3.6em; overflow-y: auto; }
        .monitor-btn-single { min-width: 72px; }
        
        /* é¢œè‰²åŒºåˆ†æ ·å¼ */
        .media-label-caller { color: #569cd6; font-weight: bold; } /* ä¸»å« - è“è‰² */
        .media-label-callee { color: #6a9955; font-weight: bold; } /* è¢«å« - ç»¿è‰² */
        .media-label-audio { color: #dcdcaa; } /* éŸ³é¢‘ - é»„è‰² */
        .media-label-video { color: #c586c0; } /* è§†é¢‘ - ç´«è‰² */
        .media-label-uplink { background: rgba(86, 156, 214, 0.1); } /* ä¸Šè¡Œ - æµ…è“èƒŒæ™¯ */
        .media-label-downlink { background: rgba(106, 153, 85, 0.1); } /* ä¸‹è¡Œ - æµ…ç»¿èƒŒæ™¯ */
        .media-stat-good { color: #4ec9b0; } /* æ­£å¸¸ç»Ÿè®¡ - é’è‰² */
        .media-stat-zero { color: #f48771; } /* é›¶åŒ… - çº¢è‰² */
        .media-stat-warn { color: #dcdcaa; } /* è­¦å‘Š - é»„è‰² */

        .sip-messages-table-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            min-height: 0; /* ç¡®ä¿ flex å­å…ƒç´ å¯ä»¥æ­£ç¡®æ»šåŠ¨ */
            overflow: hidden; /* å¤–å±‚å®¹å™¨ä¸æ»šåŠ¨ï¼Œç”±å†…å±‚å®¹å™¨æ»šåŠ¨ */
        }

        .sip-messages-table-scroll-wrapper {
            flex: 1;
            overflow: auto;
            min-height: 0;
            /* æ·»åŠ åº•éƒ¨ paddingï¼Œç¡®ä¿æœ€åå‡ æ¡æ¶ˆæ¯å¯è§ */
            padding-bottom: 50px;
        }

        .sip-messages-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            font-family: 'Consolas', 'Monaco', monospace;
            table-layout: auto; /* å…è®¸åˆ—å®½è‡ªé€‚åº” */
        }

        .sip-messages-table thead {
            position: sticky;
            top: 0;
            background: #2d2d30;
            z-index: 10;
        }

        .sip-messages-spacer-row td {
            padding: 6px 8px !important;
            border: none !important;
            background: transparent !important;
            height: auto;
        }

        .sip-messages-table th {
            padding: 8px;
            text-align: left;
            border-bottom: 2px solid #3e3e42;
            color: #cccccc;
            font-weight: bold;
            background: #2d2d30;
            position: relative;
            white-space: nowrap; /* é˜²æ­¢è¡¨å¤´æ–‡å­—æ¢è¡Œ */
            min-width: 80px; /* æœ€å°åˆ—å®½ */
        }
        
        /* åˆ—å®½è°ƒæ•´æ‰‹æŸ„ */
        .sip-messages-table th .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            cursor: col-resize;
            background: transparent;
            z-index: 11;
        }
        
        .sip-messages-table th .resize-handle:hover {
            background: #007acc;
        }
        
        .sip-messages-table th.resizing {
            user-select: none;
        }

        .sip-messages-table td {
            padding: 6px 8px;
            border-bottom: 1px solid #2d2d30;
            color: #d4d4d4;
            white-space: nowrap; /* é˜²æ­¢å•å…ƒæ ¼å†…å®¹æ¢è¡Œ */
            overflow: hidden;
            text-overflow: ellipsis; /* è¶…å‡ºéƒ¨åˆ†æ˜¾ç¤ºçœç•¥å· */
        }

        .sip-messages-table tbody tr {
            cursor: pointer;
            transition: background 0.15s;
        }

        .sip-messages-table tbody tr:hover {
            background: #2d2d30;
        }

        .sip-messages-table tbody tr.selected {
            background: #0e639c;
        }

        .table-header {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .table-header span {
            font-weight: bold;
        }

        .column-filter {
            background: #3c3c3c;
            border: 1px solid #4ec9b0;
            color: #d4d4d4;
            padding: 3px 6px;
            border-radius: 2px;
            font-size: 10px;
            width: 100%;
            box-sizing: border-box;
        }

        .column-filter:focus {
            outline: none;
            border-color: #4ec9b0;
            background: #3e3e42;
        }

        /* æ¶ˆæ¯è¯¦æƒ…å¯¹è¯æ¡† */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
        }

        .modal-content {
            background-color: #1e1e1e;
            margin: 5% auto;
            padding: 0;
            border: 1px solid #3e3e42;
            width: 80%;
            max-width: 1000px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            border-radius: 4px;
        }

        .modal-header {
            padding: 15px 20px;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            color: #d4d4d4;
            font-size: 16px;
        }

        .modal-close {
            background: none;
            border: none;
            color: #d4d4d4;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
        }

        .modal-close:hover {
            color: #fff;
            background: #3e3e42;
            border-radius: 3px;
        }

        .modal-body {
            flex: 1;
            overflow: auto;
            padding: 20px;
        }

        .modal-body pre {
            margin: 0;
            color: #d4d4d4;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        #history-content {
            flex: 1;
            display: none;
            flex-direction: column;
            min-height: 0;
        }
        
        #history-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            font-size: 13px;
            min-height: 0;
        }
        
        #history-detail {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            font-size: 13px;
            background: #1a1a1a;
            border-top: 1px solid #3e3e42;
            display: none;
            min-height: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.6;
        }
        
        #history-detail.show {
            display: block;
        }
        
        #history-detail .output-entry {
            color: #d4d4d4;
        }
        
        .history-item {
            background: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 10px 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .history-item:hover {
            background: #3c3c3c;
            border-color: #4ec9b0;
        }
        
        .history-item.selected {
            background: #3c3c3c;
            border-color: #4ec9b0;
        }
        
        .history-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .history-item-command {
            color: #4ec9b0;
            font-weight: 500;
        }
        
        .history-item-time {
            color: #858585;
            font-size: 11px;
        }
        
        .history-item-result {
            color: #d4d4d4;
            font-size: 12px;
            opacity: 0.8;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #output-content {
            color: #d4d4d4;
        }

        .output-entry {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }

        .output-command {
            color: #4ec9b0;
            margin-bottom: 5px;
        }

        .output-time {
            color: #858585;
            font-size: 11px;
            margin-bottom: 5px;
        }

        .output-result {
            color: #d4d4d4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .output-error {
            color: #f48771;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .output-success {
            color: #4ade80;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* è¾“å…¥åŒºåŸŸ */
        #input-area {
            background: #252526;
            padding: 10px 15px;
            height: 33vh;  /* é»˜è®¤å é¡µé¢é«˜åº¦çš„ä¸‰åˆ†ä¹‹ä¸€ */
            min-height: 50px;
            max-height: 600px;  /* å¢åŠ åˆ° 600pxï¼Œå…è®¸æ›´å¤šå‚æ•°æ˜¾ç¤º */
            display: flex;  /* ä½¿ç”¨ flex å¸ƒå±€ */
            flex-direction: column;  /* å‚ç›´æ’åˆ— */
        }

        #command-input-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #3c3c3c;
            border: 1px solid #555;
            border-radius: 3px;
            padding: 5px 10px;
            position: relative;
            flex-shrink: 0;  /* é˜²æ­¢å‘½ä»¤è¾“å…¥æ¡†è¢«å‹ç¼© */
        }
        
        /* å‘½ä»¤è‡ªåŠ¨è¡¥å…¨ä¸‹æ‹‰èœå• */
        #autocomplete-dropdown {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: #2d2d30;
            border: 1px solid #555;
            border-bottom: none;
            border-radius: 3px 3px 0 0;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
        }
        
        .autocomplete-item {
            padding: 8px 15px;
            cursor: pointer;
            color: #d4d4d4;
            border-bottom: 1px solid #3e3e42;
        }
        
        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: #094771;
        }
        
        .autocomplete-item .command-name {
            color: #4ec9b0;
            font-weight: bold;
        }
        
        .autocomplete-item .command-desc {
            color: #858585;
            font-size: 11px;
            margin-left: 10px;
        }

        #command-input-wrapper.focused {
            border-color: #007acc;
        }
        
        /* å‚æ•°è¾“å…¥è¡¨å•æ ·å¼ */
        #param-form {
            margin-top: 10px;
            background: #2d2d30;
            border: 1px solid #555;
            border-radius: 3px;
            padding: 10px;
            flex: 1;  /* è‡ªåŠ¨å¡«å…… input-area çš„å‰©ä½™ç©ºé—´ */
            min-height: 0;  /* å…è®¸ç¼©å°åˆ°å†…å®¹é«˜åº¦ */
            display: flex;
            flex-direction: column;
            position: relative;
            overflow-y: auto;  /* ä¿æŒæ»šåŠ¨æ¡ */
        }
        
        /* å‚æ•°è¡¨å•æ‹–åŠ¨æ¡ï¼ˆå·²ç¦ç”¨ï¼Œå› ä¸ºä½¿ç”¨ flex: 1 è‡ªåŠ¨å¡«å……ï¼‰ */
        .param-form-resizer {
            display: none;  /* éšè—æ‹–åŠ¨æ¡ */
        }
        
        .param-form-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #3e3e42;
        }
        
        .param-form-title {
            color: #4ec9b0;
            font-weight: bold;
            font-size: 12px;
        }
        
        .param-form-close {
            background: none;
            border: none;
            color: #858585;
            cursor: pointer;
            font-size: 18px;
            padding: 0;
            width: 24px;
            height: 24px;
            line-height: 24px;
            text-align: center;
            border-radius: 3px;
        }
        
        .param-form-close:hover {
            background: #3e3e42;
            color: #d4d4d4;
        }
        
        #param-form-fields {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            padding-top: 5px;
            /* ç§»é™¤ overflow-y å’Œ flex: 1ï¼Œè®©å†…å®¹è‡ªé€‚åº”é«˜åº¦ */
        }
        
        .param-field {
            display: flex;
            flex-direction: column;
        }
        
        .param-field label {
            color: #d4d4d4;
            font-size: 11px;
            margin-bottom: 4px;
        }
        
        .param-field .required {
            color: #f48771;
        }
        
        .param-field input,
        .param-field select {
            background: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            padding: 6px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        
        .param-field input:focus,
        .param-field select:focus {
            outline: none;
            border-color: #007acc;
        }

        .input-prompt {
            color: #4ec9b0;
            font-weight: bold;
        }

        #command-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #d4d4d4;
            font-family: inherit;
            font-size: 13px;
            outline: none;
        }

        .execute-btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 6px 15px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .execute-btn:hover {
            background: #1177bb;
        }

        .execute-btn:active {
            background: #0d5789;
        }

        /* å³ä¾§æ—¥å¿—é¢æ¿ */
        #log-panel {
            background: #252526;
            display: flex;
            flex-direction: column;
            min-height: 0;
            width: 350px;
            min-width: 250px;
            max-width: 800px;
            transition: width 0.3s ease, min-width 0.3s ease;
        }
        
        #log-panel.collapsed {
            display: none;
        }
        
        .resizer.collapsed {
            display: none;
        }
        
        /* æµ®åŠ¨å±•å¼€æŒ‰é’® */
        .floating-expand-btn {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            background: #2d2d30;
            border: 1px solid #4ec9b0;
            color: #4ec9b0;
            padding: 8px 4px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
            opacity: 0.3;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            display: none;
        }
        
        .floating-expand-btn:hover {
            background: #4ec9b0;
            color: #1e1e1e;
            opacity: 1;
            transform: translateY(-50%) scale(1.1);
        }
        
        #left-expand-btn {
            left: 0;
        }
        
        #right-expand-btn {
            right: 0;
        }
        
        #left-expand-btn.show,
        #right-expand-btn.show {
            display: block;
        }

        .log-header {
            padding: 15px;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .log-header h3 {
            font-size: 14px;
            color: #cccccc;
        }

        .log-controls {
            display: flex;
            gap: 5px;
        }

        .log-btn {
            background: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .log-btn:hover {
            background: #4a4a4a;
        }
        
        /* æ”¶èµ·/å±•å¼€æŒ‰é’®æ ·å¼ï¼ˆåœ¨æ‹–åŠ¨æ¡ä¸Šï¼‰*/
        .toggle-panel-btn {
            background: #2d2d30;
            border: 1px solid #4ec9b0;
            color: #4ec9b0;
            padding: 4px 2px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 10px;
            line-height: 1;
            transition: all 0.2s ease;
            opacity: 0.2;
            position: absolute;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
            width: 16px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .toggle-panel-btn:hover {
            background: #4ec9b0;
            color: #1e1e1e;
            opacity: 1;
            transform: scale(1.05);
        }
        
        /* è¡¥å…¨æŒ‰é’®æ ·å¼ */
        /* å†å²å¯¼èˆªæŒ‰é’® */
        .history-nav-btn {
            background: #3c3c3c;
            border: 1px solid #555;
            color: #cccccc;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
        }
        
        .history-nav-btn:hover:not(:disabled) {
            background: #4a4a4a;
            border-color: #4ec9b0;
            color: #4ec9b0;
        }
        
        .history-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .parse-btn {
            background: #3c3c3c;
            border: 1px solid #555;
            color: #9cdcfe;
            padding: 8px 16px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .parse-btn:hover {
            background: #4a4a4a;
            border-color: #9cdcfe;
            transform: translateY(-1px);
        }
        
        .parse-btn:active {
            transform: translateY(0);
        }

        #log-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 11px;
            line-height: 1.5;
            min-height: 0; /* ç¡®ä¿ flex å­å…ƒç´ å¯ä»¥æ»šåŠ¨ */
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 3px 5px;
            border-left: 2px solid transparent;
        }

        .log-entry.DEBUG {
            color: #858585;
            border-left-color: #858585;
        }

        .log-entry.INFO {
            color: #4ec9b0;
            border-left-color: #4ec9b0;
        }

        .log-entry.WARNING {
            color: #dcdcaa;
            border-left-color: #dcdcaa;
        }

        .log-entry.ERROR {
            color: #f48771;
            border-left-color: #f48771;
        }

        .log-time {
            color: #858585;
            margin-right: 5px;
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        ::-webkit-scrollbar-thumb {
            background: #424242;
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4e4e4e;
        }

        /* åŠ è½½åŠ¨ç”» */
        .loading {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #4ec9b0;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* å“åº”å¼ */
        @media (max-width: 1024px) {
            #command-tree-panel {
                width: 250px;
            }
            #log-panel {
                width: 300px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- å¤´éƒ¨ -->
        <div id="header">
            <h1>ğŸ–¥ï¸ IMS MML ç®¡ç†ç»ˆç«¯</h1>
            <div class="status">
                <div class="status-indicator">
                    <span class="status-dot"></span>
                    <span>æœåŠ¡è¿è¡Œä¸­</span>
                </div>
                <div class="status-indicator">
                    <span id="time"></span>
                </div>
                <div class="user-info">
                    <span class="username" id="current-username"></span>
                    <button class="logout-btn" id="logout-btn" title="é€€å‡ºç™»å½•">é€€å‡º</button>
                </div>
            </div>
        </div>

        <!-- æµ®åŠ¨å±•å¼€æŒ‰é’® -->
        <button class="floating-expand-btn" id="left-expand-btn" title="å±•å¼€å‘½ä»¤ç›®å½•">â–¶</button>
        <button class="floating-expand-btn" id="right-expand-btn" title="å±•å¼€æ—¥å¿—é¢æ¿">â—€</button>
        
        <!-- ä¸»åŒºåŸŸ -->
        <div id="main-area">
        <!-- å·¦ä¾§å‘½ä»¤æ ‘ -->
        <div id="command-tree-panel">
            <div class="tree-header">
                <h3>ğŸ“š å‘½ä»¤ç›®å½•</h3>
                <input type="text" id="tree-search" placeholder="æœç´¢å‘½ä»¤...">
            </div>
            <div id="command-tree"></div>
        </div>

        <!-- å·¦ä¾§æ‹–åŠ¨åˆ†éš”æ¡ -->
        <div class="resizer" id="left-resizer">
            <button class="toggle-panel-btn" id="toggle-left-panel" title="æ”¶èµ·/å±•å¼€å‘½ä»¤ç›®å½•">â—€</button>
        </div>

        <!-- ä¸­é—´é¢æ¿ -->
        <div id="middle-panel">
            <!-- è¾“å‡ºåŒºåŸŸ -->
            <div id="output-area">
                <!-- é¡µç­¾ -->
                <div id="output-tabs">
                    <button class="output-tab active" id="current-tab">å½“å‰å›æ˜¾</button>
                    <button class="output-tab" id="history-tab">å†å²è®°å½•</button>
                    <button class="output-tab" id="sip-messages-tab">ğŸ“¡ SIPæ¶ˆæ¯è·Ÿè¸ª</button>
                    <button class="output-tab" id="media-endpoints-tab">ğŸ“» åª’ä½“ç«¯ç‚¹å¯è§†åŒ–</button>
                </div>
                
                <!-- å½“å‰å›æ˜¾å†…å®¹ -->
                <div id="output-content">
                    <div class="output-entry">
                        <div class="output-time">ç³»ç»Ÿæ—¶é—´: <span id="welcome-time"></span></div>
                        <div class="output-result">
æ¬¢è¿ä½¿ç”¨ IMS MML ç®¡ç†ç»ˆç«¯
=================================================================

å‘½ä»¤æ ¼å¼: VERB OBJECT [PARAM1=VALUE1] [PARAM2=VALUE2] ...

å¿«é€Ÿå¼€å§‹:
  DSP SYSINFO           - æŸ¥çœ‹ç³»ç»Ÿä¿¡æ¯
  DSP REG ALL           - æŸ¥çœ‹æ³¨å†Œåˆ—è¡¨
  DSP CALL ACTIVE       - æŸ¥çœ‹æ´»è·ƒå‘¼å«
  HELP ALL              - æ˜¾ç¤ºæ‰€æœ‰å‘½ä»¤å¸®åŠ©

æç¤º: å·¦ä¾§å¯é€‰æ‹©å‘½ä»¤ï¼Œæˆ–åœ¨ä¸‹æ–¹ç›´æ¥è¾“å…¥
=================================================================
                        </div>
                    </div>
                    <!-- æ»šåŠ¨é”šç‚¹ï¼šç”¨äºå¯é çš„è‡ªåŠ¨æ»šåŠ¨ -->
                    <div id="output-anchor" style="height: 1px;"></div>
                </div>
                
                <!-- åª’ä½“ç«¯ç‚¹å¯è§†åŒ–å†…å®¹ -->
                <div id="media-endpoints-content" style="display: none;">
                    <div class="sip-messages-controls">
                        <div class="sip-messages-control-row">
                            <button id="media-endpoints-refresh-btn" class="sip-messages-btn">åˆ·æ–°</button>
                            <label><input type="checkbox" id="media-endpoints-auto-refresh" checked> æ¯ 2 ç§’è‡ªåŠ¨åˆ·æ–°</label>
                            <span id="media-endpoints-summary" class="sip-messages-stats">åŠ è½½ä¸­...</span>
                        </div>
                    </div>
                    <div id="media-endpoints-diagnosis" class="media-endpoints-diagnosis"></div>
                    <div id="media-endpoints-sessions" class="media-endpoints-sessions"></div>
                </div>
                
                <!-- åª’ä½“ç›‘å¬çª—å£ï¼šä¸»è¢«å«éŸ³è§†é¢‘å››è·¯ï¼Œå¯å•ç‹¬é™éŸ³ -->
                <div id="media-monitor-window" class="media-monitor-window">
                    <div class="media-monitor-header">
                        <div class="media-monitor-title" id="media-monitor-title">åª’ä½“æµç›‘å¬</div>
                        <button class="media-monitor-close" id="media-monitor-close">&times;</button>
                    </div>
                    <div class="media-monitor-content">
                        <div class="media-monitor-stats" id="media-monitor-stats">
                            <div class="media-monitor-stat-item">
                                <div class="media-monitor-stat-label">æ¥æ”¶åŒ…æ•°</div>
                                <div class="media-monitor-stat-value" id="stat-packets-received">0</div>
                            </div>
                            <div class="media-monitor-stat-item">
                                <div class="media-monitor-stat-label">å‘é€åŒ…æ•°</div>
                                <div class="media-monitor-stat-value" id="stat-packets-sent">0</div>
                            </div>
                            <div class="media-monitor-stat-item">
                                <div class="media-monitor-stat-label">æ€»å­—èŠ‚æ•°</div>
                                <div class="media-monitor-stat-value" id="stat-total-bytes">0</div>
                            </div>
                            <div class="media-monitor-stat-item">
                                <div class="media-monitor-stat-label">ä¸¢åŒ…(ç¼“å†²æ»¡)</div>
                                <div class="media-monitor-stat-value" id="stat-packets-dropped">0</div>
                            </div>
                        </div>
                        <!-- å››è·¯ï¼šä¸»å«éŸ³é¢‘ã€è¢«å«éŸ³é¢‘ã€ä¸»å«è§†é¢‘ã€è¢«å«è§†é¢‘ï¼Œæ¯è·¯å¯é™éŸ³ -->
                        <div id="media-monitor-panels" class="media-monitor-panels">
                            <div class="media-monitor-panel" id="panel-audio-a" data-stream-type="audio-a">
                                <div class="media-monitor-panel-head">
                                    <span class="media-monitor-panel-title">ğŸ¤ ä¸»å«éŸ³é¢‘</span>
                                    <label class="media-monitor-mute"><input type="checkbox" id="mute-audio-a" class="media-monitor-mute-cb"> é™éŸ³</label>
                                </div>
                                <div class="media-monitor-panel-body" id="panel-body-audio-a">â€”</div>
                            </div>
                            <div class="media-monitor-panel" id="panel-audio-b" data-stream-type="audio-b">
                                <div class="media-monitor-panel-head">
                                    <span class="media-monitor-panel-title">ğŸ¤ è¢«å«éŸ³é¢‘</span>
                                    <label class="media-monitor-mute"><input type="checkbox" id="mute-audio-b" class="media-monitor-mute-cb"> é™éŸ³</label>
                                </div>
                                <div class="media-monitor-panel-body" id="panel-body-audio-b">â€”</div>
                            </div>
                            <div class="media-monitor-panel" id="panel-video-a" data-stream-type="video-a">
                                <div class="media-monitor-panel-head">
                                    <span class="media-monitor-panel-title">ğŸ“¹ ä¸»å«è§†é¢‘</span>
                                    <label class="media-monitor-mute"><input type="checkbox" id="mute-video-a" class="media-monitor-mute-cb"> é™éŸ³</label>
                                </div>
                                <div class="media-monitor-panel-body media-monitor-video-wrap" id="panel-body-video-a"><canvas id="media-monitor-canvas-video-a" class="media-monitor-canvas" width="320" height="240"></canvas><div class="media-monitor-panel-info" id="info-video-a"></div></div>
                            </div>
                            <div class="media-monitor-panel" id="panel-video-b" data-stream-type="video-b">
                                <div class="media-monitor-panel-head">
                                    <span class="media-monitor-panel-title">ğŸ“¹ è¢«å«è§†é¢‘</span>
                                    <label class="media-monitor-mute"><input type="checkbox" id="mute-video-b" class="media-monitor-mute-cb"> é™éŸ³</label>
                                </div>
                                <div class="media-monitor-panel-body media-monitor-video-wrap" id="panel-body-video-b"><canvas id="media-monitor-canvas-video-b" class="media-monitor-canvas" width="320" height="240"></canvas><div class="media-monitor-panel-info" id="info-video-b"></div></div>
                            </div>
                        </div>
                        <div class="media-monitor-status" id="media-monitor-status">æœªè¿æ¥</div>
                    </div>
                </div>

                <!-- SIPæ¶ˆæ¯è·Ÿè¸ªå†…å®¹ -->
                <div id="sip-messages-content" style="display: none;">
                    <div class="sip-messages-controls">
                        <div class="sip-messages-control-row">
                            <button id="sip-messages-clear-btn" class="sip-messages-btn">æ¸…ç©º</button>
                            <button id="sip-messages-refresh-btn" class="sip-messages-btn">åˆ·æ–°</button>
                            <button id="sip-messages-pause-btn" class="sip-messages-btn">æš‚åœè·Ÿè¸ª</button>
                            <label style="margin-left: 15px; color: #d4d4d4; cursor: pointer;">
                                <input type="checkbox" id="sip-messages-show-retransmissions" style="margin-right: 5px;">
                                æ˜¾ç¤ºé‡ä¼ æ¶ˆæ¯
                            </label>
                            <span id="sip-messages-stats" style="margin-left: 15px;">åŠ è½½ä¸­...</span>
                        </div>
                    </div>
                    <div id="sip-messages-table-container" class="sip-messages-table-container">
                        <div class="sip-messages-table-scroll-wrapper">
                            <table id="sip-messages-table" class="sip-messages-table">
                            <thead>
                                <tr>
                                    <th data-column="time_str">
                                        <div class="table-header">
                                            <span>æ—¶é—´</span>
                                            <input type="text" class="column-filter" data-column="time_str" placeholder="è¿‡æ»¤æ—¶é—´...">
                                        </div>
                                        <div class="resize-handle"></div>
                                    </th>
                                    <th data-column="method">
                                        <div class="table-header">
                                            <span>æ¶ˆæ¯ç±»å‹</span>
                                            <input type="text" class="column-filter" data-column="method" placeholder="è¿‡æ»¤ç±»å‹...">
                                        </div>
                                        <div class="resize-handle"></div>
                                    </th>
                                    <th data-column="direction">
                                        <div class="table-header">
                                            <span>æ–¹å‘</span>
                                            <input type="text" class="column-filter" data-column="direction" placeholder="è¿‡æ»¤æ–¹å‘...">
                                        </div>
                                        <div class="resize-handle"></div>
                                    </th>
                                    <th data-column="registered_user">
                                        <div class="table-header">
                                            <span>æ³¨å†Œå·ç </span>
                                            <input type="text" class="column-filter" data-column="registered_user" placeholder="è¿‡æ»¤æ³¨å†Œå·...">
                                        </div>
                                        <div class="resize-handle"></div>
                                    </th>
                                    <th data-column="from_user">
                                        <div class="table-header">
                                            <span>ä¸»å«</span>
                                            <input type="text" class="column-filter" data-column="from_user" placeholder="è¿‡æ»¤ä¸»å«...">
                                        </div>
                                        <div class="resize-handle"></div>
                                    </th>
                                    <th data-column="callee">
                                        <div class="table-header">
                                            <span>è¢«å«</span>
                                            <input type="text" class="column-filter" data-column="callee" placeholder="è¿‡æ»¤è¢«å«...">
                                        </div>
                                        <div class="resize-handle"></div>
                                    </th>
                                    <th data-column="udp_addr">
                                        <div class="table-header">
                                            <span>UDP IPå±‚ (æºâ†’ç›®æ ‡)</span>
                                            <input type="text" class="column-filter" data-column="udp_addr" placeholder="è¿‡æ»¤UDPåœ°å€...">
                                        </div>
                                        <div class="resize-handle"></div>
                                    </th>
                                    <th data-column="sip_addr">
                                        <div class="table-header">
                                            <span>SIPåè®®å±‚ (æºâ†’ç›®æ ‡)</span>
                                            <input type="text" class="column-filter" data-column="sip_addr" placeholder="è¿‡æ»¤SIPåœ°å€...">
                                        </div>
                                        <div class="resize-handle"></div>
                                    </th>
                                    <th data-column="call_id">
                                        <div class="table-header">
                                            <span>Call-ID</span>
                                            <input type="text" class="column-filter" data-column="call_id" placeholder="è¿‡æ»¤Call-ID...">
                                        </div>
                                        <div class="resize-handle"></div>
                                    </th>
                                    <th data-column="sdp_info">
                                        <div class="table-header">
                                            <span>SDPä¿¡æ¯</span>
                                            <input type="text" class="column-filter" data-column="sdp_info" placeholder="è¿‡æ»¤SDP...">
                                        </div>
                                        <div class="resize-handle"></div>
                                    </th>
                                </tr>
                            </thead>
                            <tbody id="sip-messages-tbody">
                                <tr><td colspan="12" style="text-align: center; color: #858585; padding: 20px;">æ­£åœ¨åŠ è½½...</td></tr>
                            </tbody>
                        </table>
                        </div>
                    </div>
                    <!-- æ¶ˆæ¯è¯¦æƒ…å¯¹è¯æ¡† -->
                    <div id="sip-message-detail-modal" class="modal" style="display: none;">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h3>SIPæ¶ˆæ¯è¯¦æƒ…</h3>
                                <button class="modal-close" id="sip-message-detail-close">&times;</button>
                            </div>
                            <div class="modal-body">
                                <pre id="sip-message-detail-content"></pre>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- å†å²è®°å½•å†…å®¹ -->
                <div id="history-content">
                    <!-- å†å²åˆ—è¡¨ -->
                    <div id="history-list">
                        <p style="color: #858585; text-align: center; margin-top: 50px;">æš‚æ— å†å²è®°å½•</p>
                    </div>
                    <!-- å†å²è¯¦æƒ… -->
                    <div id="history-detail">
                        <p style="color: #858585; text-align: center; margin-top: 50px;">è¯·é€‰æ‹©ä¸€æ¡å†å²è®°å½•æŸ¥çœ‹è¯¦æƒ…</p>
                    </div>
                </div>
            </div>

            <!-- æ°´å¹³æ‹–åŠ¨åˆ†éš”æ¡ -->
            <div class="resizer resizer-horizontal" id="horizontal-resizer"></div>

            <!-- è¾“å…¥åŒºåŸŸ -->
            <div id="input-area">
                <div id="command-input-wrapper">
                    <!-- è‡ªåŠ¨è¡¥å…¨ä¸‹æ‹‰æ¡† -->
                    <div id="autocomplete-dropdown"></div>
                    <span class="input-prompt">MML></span>
                    <input type="text" id="command-input" placeholder="è¾“å…¥ MML å‘½ä»¤..." autocomplete="off">
                    <button class="history-nav-btn" id="history-prev-btn" title="ä¸Šä¸€æ¡å†å²å‘½ä»¤ (â†‘)">â†</button>
                    <button class="history-nav-btn" id="history-next-btn" title="ä¸‹ä¸€æ¡å†å²å‘½ä»¤ (â†“)">â†’</button>
                    <button class="parse-btn" id="parse-btn" title="è§£æå‘½ä»¤å¹¶è¡¥å…¨åˆ°å‚æ•°è¡¨å•">è¡¥å…¨</button>
                    <button class="execute-btn" id="execute-btn">æ‰§è¡Œ</button>
                </div>
                <!-- å‚æ•°è¾“å…¥è¡¨å•ï¼ˆæ ¹æ®å‘½ä»¤è‡ªåŠ¨æ˜¾ç¤º/éšè—ï¼‰ -->
                <div id="param-form" style="display: none;">
                    <!-- æ‹–åŠ¨æ¡ -->
                    <div class="param-form-resizer" id="param-form-resizer"></div>
                    <div class="param-form-header">
                        <span class="param-form-title">å‘½ä»¤å‚æ•°</span>
                    </div>
                    <div id="param-form-fields"></div>
                </div>
            </div>
        </div>

        <!-- å³ä¾§æ‹–åŠ¨åˆ†éš”æ¡ -->
        <div class="resizer" id="right-resizer">
            <button class="toggle-panel-btn" id="toggle-right-panel" title="æ”¶èµ·/å±•å¼€æ—¥å¿—é¢æ¿">â–¶</button>
        </div>

        <!-- å³ä¾§æ—¥å¿—é¢æ¿ -->
        <div id="log-panel">
            <div class="log-header">
                <h3>ğŸ“‹ å®æ—¶æ—¥å¿—</h3>
                <div class="log-controls">
                    <button class="log-btn" id="clear-log-btn">æ¸…ç©º</button>
                    <button class="log-btn" id="pause-log-btn">æš‚åœ</button>
                </div>
            </div>
            <div id="log-content">
                <div class="log-entry INFO">
                    <span class="log-time" id="log-start-time"></span>
                    <span>æ—¥å¿—ç³»ç»Ÿå·²å¯åŠ¨</span>
                </div>
                <!-- æ»šåŠ¨é”šç‚¹ï¼šç”¨äºå¯é çš„è‡ªåŠ¨æ»šåŠ¨ -->
                <div id="log-anchor" style="height: 1px;"></div>
            </div>
        </div>
        </div> <!-- ç»“æŸ main-area -->
    </div> <!-- ç»“æŸ container -->

    <script>
        // å…¨å±€å˜é‡
        let commandHistory = [];
        let historyIndex = -1;
        let logPaused = false;
        let ws = null;
        let autocompleteIndex = -1;
        let allCommands = [];  // å­˜å‚¨æ‰€æœ‰å‘½ä»¤ç”¨äºè‡ªåŠ¨è¡¥å…¨

        // åˆå§‹åŒ–æ—¶é—´æ˜¾ç¤º
        function updateTime() {
            const now = new Date();
            const timeStr = now.toLocaleString('zh-CN', { hour12: false });
            document.getElementById('time').textContent = timeStr;
            
            if (!document.getElementById('welcome-time').textContent) {
                document.getElementById('welcome-time').textContent = timeStr;
                document.getElementById('log-start-time').textContent = timeStr;
            }
        }
        updateTime();
        setInterval(updateTime, 1000);

        // åŠ è½½å‘½ä»¤æ ‘
        async function loadCommandTree() {
            try {
                const response = await fetch('/api/command_tree');
                const tree = await response.json();
                renderCommandTree(tree);
                
                // æ”¶é›†æ‰€æœ‰å‘½ä»¤ç”¨äºè‡ªåŠ¨è¡¥å…¨
                allCommands = [];
                for (const [category, data] of Object.entries(tree)) {
                    for (const [name, cmd] of Object.entries(data.commands)) {
                        allCommands.push({
                            name: name,
                            command: cmd,
                            category: category
                        });
                    }
                }
            } catch (error) {
                console.error('åŠ è½½å‘½ä»¤æ ‘å¤±è´¥:', error);
            }
        }

        // æ¸²æŸ“å‘½ä»¤æ ‘
        function renderCommandTree(tree) {
            const container = document.getElementById('command-tree');
            container.innerHTML = '';

            for (const [category, data] of Object.entries(tree)) {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'tree-category';

                // åˆ†ç±»å¤´éƒ¨
                const header = document.createElement('div');
                header.className = 'category-header';
                header.innerHTML = `
                    <span class="category-icon">${data.icon || 'ğŸ“'}</span>
                    <span class="category-name">${category}</span>
                    <span class="category-toggle">â–¶</span>
                `;

                // å‘½ä»¤åˆ—è¡¨
                const commandsDiv = document.createElement('div');
                commandsDiv.className = 'category-commands';

                for (const [name, cmd] of Object.entries(data.commands)) {
                    const cmdItem = document.createElement('div');
                    cmdItem.className = 'command-item';
                    cmdItem.textContent = name;
                    cmdItem.title = cmd;
                    cmdItem.dataset.command = cmd;

                    cmdItem.addEventListener('click', () => {
                        document.getElementById('command-input').value = cmd;
                        document.querySelectorAll('.command-item').forEach(item => {
                            item.classList.remove('selected');
                        });
                        cmdItem.classList.add('selected');
                        document.getElementById('command-input').focus();
                        
                        // è§¦å‘å‚æ•°è¡¨å•æ£€æŸ¥
                        checkAndShowParamForm();
                    });

                    commandsDiv.appendChild(cmdItem);
                }

                // æŠ˜å /å±•å¼€
                header.addEventListener('click', () => {
                    const toggle = header.querySelector('.category-toggle');
                    if (commandsDiv.classList.contains('show')) {
                        commandsDiv.classList.remove('show');
                        toggle.classList.remove('expanded');
                    } else {
                        commandsDiv.classList.add('show');
                        toggle.classList.add('expanded');
                    }
                });

                categoryDiv.appendChild(header);
                categoryDiv.appendChild(commandsDiv);
                container.appendChild(categoryDiv);
            }
        }

        // å†å²è®°å½•è¯¦ç»†ä¿¡æ¯ï¼ˆåŒ…å«å‘½ä»¤å’Œç»“æœï¼‰
        const commandHistoryDetails = [];
        
        // æ‰§è¡Œå‘½ä»¤
        async function executeCommand() {
            const input = document.getElementById('command-input');
            const command = input.value.trim();

            if (!command) return;

            // æ·»åŠ åˆ°å†å²
            commandHistory.unshift(command);
            historyIndex = -1;

            // æ˜¾ç¤ºå‘½ä»¤
            appendOutput(command, 'æ‰§è¡Œä¸­...', 'pending');

            try {
                const response = await fetch('/api/execute', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ command })
                });

                const result = await response.json();

                // æ˜¾ç¤ºç»“æœ
                appendOutput(command, result.output, result.retcode === 0 ? 'success' : 'error', result.timestamp);
                
                // ä¿å­˜åˆ°å†å²è®°å½•è¯¦æƒ…
                commandHistoryDetails.unshift({
                    id: Date.now(),
                    command: command,
                    output: result.output,
                    status: result.retcode === 0 ? 'success' : 'error',
                    timestamp: result.timestamp || new Date().toLocaleString('zh-CN')
                });
                
                // âœ… é™åˆ¶å†å²è®°å½•æ•°é‡ï¼Œé˜²æ­¢å†…å­˜æ— é™å¢é•¿
                const maxHistoryCount = 100;
                if (commandHistoryDetails.length > maxHistoryCount) {
                    commandHistoryDetails.splice(maxHistoryCount);
                }
                
                // æ›´æ–°å†å²è®°å½•æ˜¾ç¤º
                updateHistoryDisplay();
                
                // æ›´æ–°å†å²æŒ‰é’®çŠ¶æ€
                updateHistoryButtons();

                // æ¸…ç©ºè¾“å…¥
                input.value = '';

            } catch (error) {
                appendOutput(command, `æ‰§è¡Œå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ·»åŠ è¾“å‡º
        function appendOutput(command, output, type, timestamp) {
            const outputContent = document.getElementById('output-content');
            const outputAnchor = document.getElementById('output-anchor');
            
            const entry = document.createElement('div');
            entry.className = 'output-entry';

            const timeStr = timestamp || new Date().toLocaleString('zh-CN', { hour12: false });

            entry.innerHTML = `
                <div class="output-command">MML> ${escapeHtml(command)}</div>
                <div class="output-time">${timeStr}</div>
                <div class="output-result ${type === 'error' ? 'output-error' : type === 'success' ? 'output-success' : ''}">${escapeHtml(output)}</div>
            `;

            // æ’å…¥åˆ°é”šç‚¹ä¹‹å‰
            outputContent.insertBefore(entry, outputAnchor);

            // é™åˆ¶è¾“å‡ºæ¡æ•°ï¼Œä¿ç•™æœ€è¿‘ 1000 æ¡ï¼ˆé˜²æ­¢é¡µé¢å¡æ­»ï¼‰
            const maxEntries = 1000;
            const entries = outputContent.querySelectorAll('.output-entry');
            if (entries.length > maxEntries) {
                // åˆ é™¤æœ€æ—§çš„æ¡ç›®ï¼ˆä»å‰é¢å¼€å§‹åˆ é™¤ï¼‰
                const deleteCount = entries.length - maxEntries;
                for (let i = 0; i < deleteCount; i++) {
                    if (entries[i]) {  // âœ… æ·»åŠ å®‰å…¨æ£€æŸ¥
                        entries[i].remove();
                    }
                }
            }

            // æ»šåŠ¨åˆ°åº•éƒ¨ï¼ˆä¿®æ­£ï¼šæ»šåŠ¨ outputContent è€Œä¸æ˜¯ outputAreaï¼‰
            // ä½¿ç”¨ requestAnimationFrame ä¼˜åŒ–æ€§èƒ½
            requestAnimationFrame(() => {
                outputContent.scrollTop = outputContent.scrollHeight;
            });
        }

        // HTML è½¬ä¹‰
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // æ·»åŠ æ—¥å¿—ï¼ˆæ”¯æŒä¸­æ–‡æ—¥å¿—å’ŒWebSocketæ—¥å¿—ï¼‰
        // æ»šåŠ¨èŠ‚æµæ ‡å¿—
        let logScrollPending = false;
        
        function appendLog(message, level = 'INFO') {
            if (logPaused) return;

            const logContent = document.getElementById('log-content');
            const logAnchor = document.getElementById('log-anchor');
            
            const entry = document.createElement('div');
            entry.className = `log-entry ${level}`;

            const now = new Date();
            const timeStr = now.toLocaleTimeString('zh-CN', { hour12: false });

            // å°†è‹±æ–‡æ—¥å¿—è½¬æ¢ä¸ºä¸­æ–‡ï¼ˆå¯é€‰ï¼‰
            const displayMessage = translateLogMessage(message);

            entry.innerHTML = `
                <span class="log-time">${timeStr}</span>
                <span>${escapeHtml(displayMessage)}</span>
            `;

            // æ’å…¥åˆ°é”šç‚¹ä¹‹å‰
            logContent.insertBefore(entry, logAnchor);

            // é™åˆ¶æ—¥å¿—æ¡æ•°ï¼ˆä½†ä¿ç•™é”šç‚¹ï¼‰
            // âœ… ä¿®å¤ï¼šä½¿ç”¨ for å¾ªç¯æ›¿ä»£ while å¾ªç¯ï¼Œé¿å…é™æ€ NodeList å¯¼è‡´çš„è¿‡åº¦åˆ é™¤
            const maxLogEntries = 500;
            const entries = logContent.querySelectorAll('.log-entry');
            if (entries.length > maxLogEntries) {
                const deleteCount = entries.length - maxLogEntries;
                for (let i = 0; i < deleteCount; i++) {
                    if (entries[i]) {
                        entries[i].remove();
                    }
                }
            }

            // æ»šåŠ¨åˆ°åº•éƒ¨ï¼ˆä½¿ç”¨ requestAnimationFrame èŠ‚æµï¼‰
            if (!logPaused && !logScrollPending) {
                logScrollPending = true;
                requestAnimationFrame(() => {
                    logContent.scrollTop = logContent.scrollHeight;
                    logScrollPending = false;
                });
            }
        }
        
        // å°†è‹±æ–‡æ—¥å¿—è½¬æ¢ä¸ºä¸­æ–‡æè¿°
        function translateLogMessage(message) {
            const translations = {
                'UDP server listening on': 'UDP æœåŠ¡å™¨ç›‘å¬',
                'Started all SIP timers': 'æ‰€æœ‰ SIP å®šæ—¶å™¨å·²å¯åŠ¨',
                'CDR system initialized': 'CDR è¯å•ç³»ç»Ÿå·²åˆå§‹åŒ–',
                'WebSocket connection established': 'WebSocket è¿æ¥å·²å»ºç«‹',
                'REGISTER': 'æ³¨å†Œ',
                'INVITE': 'å‘¼å«é‚€è¯·',
                'BYE': 'ç»“æŸé€šè¯',
                'MESSAGE': 'æ¶ˆæ¯',
                'ACK': 'ç¡®è®¤',
                'CANCEL': 'å–æ¶ˆ',
                'OPTIONS': 'é€‰é¡¹æŸ¥è¯¢',
                'Received': 'æ¥æ”¶',
                'Sent': 'å‘é€',
                'Failed': 'å¤±è´¥',
                'Success': 'æˆåŠŸ',
                'Error': 'é”™è¯¯',
                'Warning': 'è­¦å‘Š',
                'Info': 'ä¿¡æ¯'
            };
            
            let translated = message;
            for (const [en, cn] of Object.entries(translations)) {
                translated = translated.replace(new RegExp(en, 'gi'), cn);
            }
            
            return translated;
        }

        // æœç´¢å‘½ä»¤
        document.getElementById('tree-search').addEventListener('input', (e) => {
            const keyword = e.target.value.toLowerCase();
            const items = document.querySelectorAll('.command-item');

            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                const cmd = item.dataset.command.toLowerCase();

                if (text.includes(keyword) || cmd.includes(keyword)) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        });

        // è¾“å…¥æ¡†ç„¦ç‚¹
        const inputWrapper = document.getElementById('command-input-wrapper');
        const commandInput = document.getElementById('command-input');

        commandInput.addEventListener('focus', () => {
            inputWrapper.classList.add('focused');
        });

        commandInput.addEventListener('blur', () => {
            inputWrapper.classList.remove('focused');
        });

        // å‘½ä»¤å†å²
        commandInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                executeCommand();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    commandInput.value = commandHistory[historyIndex];
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    commandInput.value = commandHistory[historyIndex];
                } else if (historyIndex === 0) {
                    historyIndex = -1;
                    commandInput.value = '';
                }
            }
        });

        // æ‰§è¡ŒæŒ‰é’®
        document.getElementById('execute-btn').addEventListener('click', executeCommand);
        
        // è¡¥å…¨æŒ‰é’® - è§£æå‘½ä»¤å¹¶å¡«å……åˆ°å‚æ•°è¡¨å•
        document.getElementById('parse-btn').addEventListener('click', () => {
            const command = document.getElementById('command-input').value.trim().toUpperCase();
            
            if (!command) {
                appendOutput('', 'è¯·å…ˆè¾“å…¥ MML å‘½ä»¤', 'error');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦åŒ¹é…å·²é…ç½®çš„å‘½ä»¤
            let matchedConfig = null;
            for (const [cmdPattern, config] of Object.entries(commandParamConfigs)) {
                if (command.startsWith(cmdPattern)) {
                    matchedConfig = { pattern: cmdPattern, config };
                    break;
                }
            }
            
            if (matchedConfig) {
                // æ˜¾ç¤ºå‚æ•°è¡¨å•
                showParamForm(matchedConfig.pattern, matchedConfig.config);
                
                // ä»å‘½ä»¤æ–‡æœ¬è§£æå‚æ•°å¹¶å¡«å……åˆ°è¡¨å•
                parseCommandToForm(command, matchedConfig.pattern);
                
                appendOutput('è¡¥å…¨', `å‘½ä»¤å·²è§£æå¹¶å¡«å……åˆ°å‚æ•°è¡¨å•: ${command}`, 'success');
            } else {
                appendOutput('è¡¥å…¨', `è¯¥å‘½ä»¤ä¸æ”¯æŒå‚æ•°è¡¨å•: ${command}`, 'error');
            }
        });
        
        // å·¦ä¾§è¾¹æ æ”¶èµ·/å±•å¼€
        let leftPanelCollapsed = false;
        const leftExpandBtn = document.getElementById('left-expand-btn');
        
        function toggleLeftPanel() {
            const panel = document.getElementById('command-tree-panel');
            const resizer = document.getElementById('left-resizer');
            const btn = document.getElementById('toggle-left-panel');
            
            if (leftPanelCollapsed) {
                // å±•å¼€
                panel.classList.remove('collapsed');
                resizer.classList.remove('collapsed');
                leftExpandBtn.classList.remove('show');
                btn.textContent = 'â—€';
                btn.title = 'æ”¶èµ·å‘½ä»¤ç›®å½•';
                leftPanelCollapsed = false;
            } else {
                // æ”¶èµ·
                panel.classList.add('collapsed');
                resizer.classList.add('collapsed');
                leftExpandBtn.classList.add('show');
                btn.textContent = 'â–¶';
                btn.title = 'å±•å¼€å‘½ä»¤ç›®å½•';
                leftPanelCollapsed = true;
            }
        }
        
        document.getElementById('toggle-left-panel').addEventListener('click', toggleLeftPanel);
        leftExpandBtn.addEventListener('click', toggleLeftPanel);
        
        // å³ä¾§è¾¹æ æ”¶èµ·/å±•å¼€
        let rightPanelCollapsed = false;
        const rightExpandBtn = document.getElementById('right-expand-btn');
        
        function toggleRightPanel() {
            const panel = document.getElementById('log-panel');
            const resizer = document.getElementById('right-resizer');
            const btn = document.getElementById('toggle-right-panel');
            
            if (rightPanelCollapsed) {
                // å±•å¼€
                panel.classList.remove('collapsed');
                resizer.classList.remove('collapsed');
                rightExpandBtn.classList.remove('show');
                btn.textContent = 'â–¶';
                btn.title = 'æ”¶èµ·æ—¥å¿—é¢æ¿';
                rightPanelCollapsed = false;
            } else {
                // æ”¶èµ·
                panel.classList.add('collapsed');
                resizer.classList.add('collapsed');
                rightExpandBtn.classList.add('show');
                btn.textContent = 'â—€';
                btn.title = 'å±•å¼€æ—¥å¿—é¢æ¿';
                rightPanelCollapsed = true;
            }
        }
        
        document.getElementById('toggle-right-panel').addEventListener('click', toggleRightPanel);
        rightExpandBtn.addEventListener('click', toggleRightPanel);

        // æ—¥å¿—æ§åˆ¶
        document.getElementById('clear-log-btn').addEventListener('click', () => {
            const logContent = document.getElementById('log-content');
            logContent.innerHTML = '';
            appendLog('æ—¥å¿—å·²æ¸…ç©º', 'INFO');
        });

        document.getElementById('pause-log-btn').addEventListener('click', (e) => {
            logPaused = !logPaused;
            e.target.textContent = logPaused ? 'ç»§ç»­' : 'æš‚åœ';
            appendLog(logPaused ? 'æ—¥å¿—å·²æš‚åœ' : 'æ—¥å¿—å·²ç»§ç»­', 'INFO');
        });

        // WebSocket è¿æ¥ï¼ˆå®æ—¶æ—¥å¿—ï¼‰
        function connectWebSocket() {
            try {
                // åŠ¨æ€è·å– WebSocket åœ°å€ï¼šä½¿ç”¨å½“å‰é¡µé¢çš„ä¸»æœºå’Œç«¯å£+1
                const wsHost = window.location.hostname;
                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                // è·å–å½“å‰ HTTP ç«¯å£ï¼Œå¦‚æœä¸ºç©ºæˆ–æ— æ•ˆåˆ™ä½¿ç”¨é»˜è®¤å€¼
                const httpPort = window.location.port ? parseInt(window.location.port) : 
                                 (window.location.protocol === 'https:' ? 443 : 80);
                
                // å¦‚æœé€šè¿‡ Cloudflare éš§é“è®¿é—®ï¼ˆtrycloudflare.comï¼‰ï¼ŒWebSocket ä½¿ç”¨ç›¸åŒç«¯å£ï¼ˆHTTP å‡çº§ï¼‰
                // å¦åˆ™ä½¿ç”¨ç«¯å£ + 1ï¼ˆç‹¬ç«‹ WebSocket æœåŠ¡å™¨ï¼‰
                const isCloudflareTunnel = window.location.hostname.includes('trycloudflare.com');
                const wsPort = isCloudflareTunnel ? httpPort : ((httpPort === 80 || httpPort === 443) ? 8889 : (httpPort + 1));
                
                // HTTPS é¡µé¢å¿…é¡»ä½¿ç”¨ WSSï¼ŒHTTP é¡µé¢ä½¿ç”¨ WS
                const wsUrl = `${wsProtocol}//${wsHost}:${wsPort}/ws/logs`;
                console.log(`[WebSocket] è¿æ¥åˆ°: ${wsUrl} (isCloudflareTunnel: ${isCloudflareTunnel})`);
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    appendLog('WebSocket è¿æ¥å·²å»ºç«‹', 'INFO');
                };

                ws.onmessage = (event) => {
                    // æœåŠ¡å™¨å‘é€çº¯æ–‡æœ¬æ ¼å¼: [LEVEL] message
                    const text = event.data;
                    
                    // æå–æ—¥å¿—çº§åˆ«å’Œæ¶ˆæ¯
                    const match = text.match(/^\[(\w+)\]\s*(.+)$/);
                    if (match) {
                        const level = match[1];  // INFO, DEBUG, WARNING, ERROR
                        const message = match[2];
                        appendLog(message, level);
                    } else {
                        // å¦‚æœæ ¼å¼ä¸åŒ¹é…ï¼Œç›´æ¥æ˜¾ç¤º
                        appendLog(text, 'INFO');
                    }
                };

                ws.onerror = () => {
                    appendLog('WebSocket è¿æ¥é”™è¯¯ï¼ˆå®æ—¶æ—¥å¿—ä¸å¯ç”¨ï¼‰', 'WARNING');
                    // å¦‚æœæ˜¯é€šè¿‡ Cloudflare éš§é“è®¿é—®ï¼Œæç¤º WebSocket ä¸å¯ç”¨
                    if (window.location.hostname.includes('trycloudflare.com')) {
                        appendLog('é€šè¿‡ Cloudflare ä¸´æ—¶éš§é“è®¿é—®æ—¶ï¼ŒWebSocket å®æ—¶æ—¥å¿—ä¸å¯ç”¨', 'WARNING');
                    }
                };

                ws.onclose = (event) => {
                    appendLog(`WebSocket è¿æ¥å·²å…³é—­ (code: ${event.code}, reason: ${event.reason || 'none'})`, 'WARNING');
                    
                    // å¦‚æœæ˜¯é€šè¿‡ Cloudflare éš§é“è®¿é—®ï¼Œä¸è‡ªåŠ¨é‡è¿
                    if (window.location.hostname.includes('trycloudflare.com')) {
                        appendLog('é€šè¿‡ Cloudflare ä¸´æ—¶éš§é“è®¿é—®ï¼Œä¸è‡ªåŠ¨é‡è¿ WebSocket', 'INFO');
                        return;
                    }
                    
                    // å¦‚æœè¿æ¥æ„å¤–å…³é—­ï¼Œå°è¯•é‡è¿ï¼ˆå»¶è¿Ÿ3ç§’ï¼‰
                    if (event.code !== 1000) {  // 1000æ˜¯æ­£å¸¸å…³é—­
                        setTimeout(() => {
                            console.log('[WebSocket] å°è¯•é‡è¿...');
                            connectWebSocket();
                        }, 3000);
                    }
                };
            } catch (error) {
                console.error('WebSocket ä¸å¯ç”¨:', error);
            }
        }

        // é¢æ¿æ‹–åŠ¨è°ƒæ•´å¤§å°åŠŸèƒ½
        function initResizers() {
            // å·¦ä¾§é¢æ¿æ‹–åŠ¨
            const leftResizer = document.getElementById('left-resizer');
            const leftPanel = document.getElementById('command-tree-panel');
            
            leftResizer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const startX = e.clientX;
                const startWidth = leftPanel.offsetWidth;
                let rafId = null;
                let currentWidth = startWidth;
                
                function onMouseMove(e) {
                    const newWidth = startWidth + (e.clientX - startX);
                    // æœ€å°40pxï¼ˆæ”¶èµ·çŠ¶æ€ï¼‰ï¼Œæœ€å¤§ä¸é™åˆ¶
                    if (newWidth >= 40) {
                        currentWidth = newWidth;
                        
                        // ä½¿ç”¨ requestAnimationFrame ä¼˜åŒ–æ€§èƒ½
                        if (rafId) {
                            cancelAnimationFrame(rafId);
                        }
                        rafId = requestAnimationFrame(() => {
                            leftPanel.style.width = currentWidth + 'px';
                        });
                    }
                }
                
                function onMouseUp() {
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                    }
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
            
            // å³ä¾§é¢æ¿æ‹–åŠ¨
            const rightResizer = document.getElementById('right-resizer');
            const rightPanel = document.getElementById('log-panel');
            
            rightResizer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const startX = e.clientX;
                const startWidth = rightPanel.offsetWidth;
                let rafId = null;
                let currentWidth = startWidth;
                
                function onMouseMove(e) {
                    const newWidth = startWidth - (e.clientX - startX);
                    // æœ€å°40pxï¼ˆæ”¶èµ·çŠ¶æ€ï¼‰ï¼Œæœ€å¤§ä¸é™åˆ¶
                    if (newWidth >= 40) {
                        currentWidth = newWidth;
                        
                        // ä½¿ç”¨ requestAnimationFrame ä¼˜åŒ–æ€§èƒ½
                        if (rafId) {
                            cancelAnimationFrame(rafId);
                        }
                        rafId = requestAnimationFrame(() => {
                            rightPanel.style.width = currentWidth + 'px';
                        });
                    }
                }
                
                function onMouseUp() {
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                    }
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
            
            // æ°´å¹³æ‹–åŠ¨ï¼ˆè¾“å‡ºåŒºåŸŸå’Œè¾“å…¥åŒºåŸŸï¼‰
            const horizontalResizer = document.getElementById('horizontal-resizer');
            const outputArea = document.getElementById('output-area');
            const inputArea = document.getElementById('input-area');
            
            horizontalResizer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const startY = e.clientY;
                const startHeight = inputArea.offsetHeight;
                let rafId = null;
                let currentHeight = startHeight;
                
                function onMouseMove(e) {
                    const newHeight = startHeight - (e.clientY - startY);
                    if (newHeight >= 50 && newHeight <= 600) {
                        currentHeight = newHeight;
                        
                        // ä½¿ç”¨ requestAnimationFrame ä¼˜åŒ–æ€§èƒ½
                        if (rafId) {
                            cancelAnimationFrame(rafId);
                        }
                        rafId = requestAnimationFrame(() => {
                            inputArea.style.height = currentHeight + 'px';
                            // å‚æ•°è¡¨å•ä½¿ç”¨ flex: 1 è‡ªåŠ¨å¡«å……å‰©ä½™ç©ºé—´ï¼Œæ— éœ€æ‰‹åŠ¨è°ƒæ•´
                        });
                    }
                }
                
                function onMouseUp() {
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                    }
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }
        
        // å‘½ä»¤å‚æ•°è¡¨å•é…ç½®
        const commandParamConfigs = {
            // æ—¥å¿—çº§åˆ«è®¾ç½®å‘½ä»¤ï¼ˆæ”¯æŒä¸¤ç§æ ¼å¼ï¼‰
            'SET LOGLEVEL': [
                { name: 'LEVEL', label: 'æ—¥å¿—çº§åˆ«', required: true, type: 'select', options: ['DEBUG', 'INFO', 'WARNING', 'ERROR'] }
            ],
            'SET LOG': [
                { name: 'LEVEL', label: 'æ—¥å¿—çº§åˆ«', required: true, type: 'select', options: ['DEBUG', 'INFO', 'WARNING', 'ERROR'] }
            ],
            // æŸ¥è¯¢æ³¨å†Œå‘½ä»¤
            'DSP REG': [
                { name: 'URI', label: 'ç”¨æˆ·URI', required: false, placeholder: 'å¦‚: 1001 æˆ– sip:1001@domain' }
            ],
            // å¼ºåˆ¶æ³¨é”€å‘½ä»¤
            'RMV REG': [
                { name: 'URI', label: 'ç”¨æˆ·URI', required: true, placeholder: 'å¦‚: 1001 æˆ– sip:1001@domain' },
                { name: 'CONFIRM', label: 'ç¡®è®¤', required: true, type: 'select', options: ['YES', 'NO'] }
            ],
            // æ¸…é™¤æ‰€æœ‰æ³¨å†Œå‘½ä»¤
            'CLR REG': [
                { name: 'CONFIRM', label: 'ç¡®è®¤', required: true, type: 'select', options: ['YES', 'NO'] }
            ],
            // å‘¼å«ç®¡ç†å‘½ä»¤
            'DSP CALL': [
                { name: 'CALLID', label: 'Call-ID', required: false, placeholder: 'ç•™ç©ºæŸ¥è¯¢æ‰€æœ‰æ´»è·ƒå‘¼å«ï¼Œå¡«å†™åˆ™æŸ¥è¯¢æŒ‡å®šå‘¼å«' }
            ],
            'RMV CALL': [
                { name: 'CALLID', label: 'Call-ID', required: true, placeholder: 'è¦æŒ‚æ–­çš„å‘¼å« Call-ID' },
                { name: 'CONFIRM', label: 'ç¡®è®¤', required: true, type: 'select', options: ['YES', 'NO'] }
            ],
            'CLR CALL': [
                { name: 'CONFIRM', label: 'ç¡®è®¤', required: true, type: 'select', options: ['YES', 'NO'] }
            ],
            // æ€§èƒ½ç›‘æ§å‘½ä»¤
            'DSP PERF': [
                { name: 'TYPE', label: 'ç›‘æ§ç±»å‹', required: false, type: 'select', options: ['ALL', 'CPU', 'MEM', 'NET', 'MSG'], placeholder: 'é»˜è®¤æ˜¾ç¤ºæ‰€æœ‰æ€§èƒ½æŒ‡æ ‡' }
            ],
            // é…ç½®ç®¡ç†å‘½ä»¤
            'DSP CFG': [
                { name: 'KEY', label: 'é…ç½®é¡¹', required: false, placeholder: 'ç•™ç©ºæŸ¥è¯¢æ‰€æœ‰é…ç½®ï¼Œæˆ–è¾“å…¥é…ç½®é¡¹åç§°ï¼ˆå¦‚: LOG.LEVELï¼‰' },
                { name: 'CATEGORY', label: 'é…ç½®åˆ†ç±»', required: false, placeholder: 'ç•™ç©ºæŸ¥è¯¢æ‰€æœ‰åˆ†ç±»ï¼Œæˆ–è¾“å…¥åˆ†ç±»åç§°' }
            ],
            'SET CFG': [
                { name: 'KEY', label: 'é…ç½®é¡¹', required: false, type: 'select', options: ['LOG.LEVEL'], placeholder: 'é€‰æ‹©è¦ä¿®æ”¹çš„é…ç½®é¡¹' },
                { name: 'VALUE', label: 'æ–°å€¼', required: true, type: 'select', options: ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'], placeholder: 'é€‰æ‹©æ–°çš„æ—¥å¿—çº§åˆ«' }
            ],
            'EXP CFG': [
                // æ— éœ€å‚æ•°
            ],
            // CDR ç®¡ç†å‘½ä»¤
            'DSP CDR': [
                { name: 'DATE', label: 'æ—¥æœŸ', required: false, placeholder: 'æ ¼å¼: YYYY-MM-DD æˆ– TODAYï¼Œç•™ç©ºä¸ºä»Šå¤©' },
                { name: 'TYPE', label: 'è®°å½•ç±»å‹', required: false, type: 'select', options: ['CALL', 'REGISTER', 'MESSAGE', 'OPTIONS'] },
                { name: 'LIMIT', label: 'æ˜¾ç¤ºæ¡æ•°', required: false, placeholder: 'é»˜è®¤ 50 æ¡' }
            ],
            'EXP CDR': [
                { name: 'DATE', label: 'æ—¥æœŸ', required: false, placeholder: 'æ ¼å¼: YYYY-MM-DD æˆ– TODAYï¼Œç•™ç©ºä¸ºä»Šå¤©' },
                { name: 'TYPE', label: 'è®°å½•ç±»å‹', required: false, type: 'select', options: ['CALL', 'REGISTER', 'MESSAGE', 'OPTIONS'] },
                { name: 'FORMAT', label: 'å¯¼å‡ºæ ¼å¼', required: false, type: 'select', options: ['CSV'] }
            ],
            'CLR CDR': [
                { name: 'BEFORE', label: 'åˆ é™¤æ­¤æ—¥æœŸä¹‹å‰çš„æ•°æ®', required: true, placeholder: 'æ ¼å¼: YYYY-MM-DD (è‡³å°‘7å¤©å‰)' },
                { name: 'CONFIRM', label: 'ç¡®è®¤', required: true, type: 'select', options: ['YES', 'NO'] }
            ],
            // æŸ¥è¯¢ç”¨æˆ·å‘½ä»¤
            'DSP USER': [
                { name: 'USERNAME', label: 'ç”¨æˆ·å', required: false, placeholder: 'ç•™ç©ºæŸ¥è¯¢æ‰€æœ‰ç”¨æˆ·' },
                { name: 'STATUS', label: 'çŠ¶æ€', required: false, type: 'select', options: ['ACTIVE', 'INACTIVE', 'SUSPENDED'] }
            ],
            // æ”¯æŒ ADD USR å’Œ ADD USER ä¸¤ç§å†™æ³•
            'ADD USER': [
                { name: 'USERNAME', label: 'ç”¨æˆ·å', required: true, placeholder: 'å¦‚: 1003' },
                { name: 'PASSWORD', label: 'å¯†ç ', required: true, placeholder: 'å¯†ç ', type: 'password' },
                { name: 'NAME', label: 'æ˜¾ç¤ºåç§°', required: false, placeholder: 'å¦‚: ç”¨æˆ·1003' },
                { name: 'PHONE', label: 'ç”µè¯å·ç ', required: false, placeholder: 'å¦‚: 13800001003' },
                { name: 'EMAIL', label: 'é‚®ç®±', required: false, placeholder: 'å¦‚: user@example.com' },
                { name: 'SERVICE', label: 'æœåŠ¡ç±»å‹', required: false, type: 'select', options: ['BASIC', 'PREMIUM', 'VIP'] }
            ],
            'ADD USR': [
                { name: 'USERNAME', label: 'ç”¨æˆ·å', required: true, placeholder: 'å¦‚: 1003' },
                { name: 'PASSWORD', label: 'å¯†ç ', required: true, placeholder: 'å¯†ç ', type: 'password' },
                { name: 'NAME', label: 'æ˜¾ç¤ºåç§°', required: false, placeholder: 'å¦‚: ç”¨æˆ·1003' },
                { name: 'PHONE', label: 'ç”µè¯å·ç ', required: false, placeholder: 'å¦‚: 13800001003' },
                { name: 'EMAIL', label: 'é‚®ç®±', required: false, placeholder: 'å¦‚: user@example.com' },
                { name: 'SERVICE', label: 'æœåŠ¡ç±»å‹', required: false, type: 'select', options: ['BASIC', 'PREMIUM', 'VIP'] }
            ],
            'MOD USER': [
                { name: 'USERNAME', label: 'ç”¨æˆ·å', required: true, placeholder: 'å¦‚: 1001' },
                { name: 'PASSWORD', label: 'æ–°å¯†ç ', required: false, placeholder: 'ç•™ç©ºè¡¨ç¤ºä¸ä¿®æ”¹' },
                { name: 'NAME', label: 'æ˜¾ç¤ºåç§°', required: false, placeholder: 'ç•™ç©ºè¡¨ç¤ºä¸ä¿®æ”¹' },
                { name: 'PHONE', label: 'ç”µè¯å·ç ', required: false, placeholder: 'ç•™ç©ºè¡¨ç¤ºä¸ä¿®æ”¹' },
                { name: 'EMAIL', label: 'é‚®ç®±', required: false, placeholder: 'ç•™ç©ºè¡¨ç¤ºä¸ä¿®æ”¹' },
                { name: 'SERVICE', label: 'æœåŠ¡ç±»å‹', required: false, type: 'select', options: ['BASIC', 'PREMIUM', 'VIP'] },
                { name: 'STATUS', label: 'çŠ¶æ€', required: false, type: 'select', options: ['ACTIVE', 'INACTIVE', 'SUSPENDED'] }
            ],
            'MOD USR': [
                { name: 'USERNAME', label: 'ç”¨æˆ·å', required: true, placeholder: 'å¦‚: 1001' },
                { name: 'PASSWORD', label: 'æ–°å¯†ç ', required: false, placeholder: 'ç•™ç©ºè¡¨ç¤ºä¸ä¿®æ”¹' },
                { name: 'NAME', label: 'æ˜¾ç¤ºåç§°', required: false, placeholder: 'ç•™ç©ºè¡¨ç¤ºä¸ä¿®æ”¹' },
                { name: 'PHONE', label: 'ç”µè¯å·ç ', required: false, placeholder: 'ç•™ç©ºè¡¨ç¤ºä¸ä¿®æ”¹' },
                { name: 'EMAIL', label: 'é‚®ç®±', required: false, placeholder: 'ç•™ç©ºè¡¨ç¤ºä¸ä¿®æ”¹' },
                { name: 'SERVICE', label: 'æœåŠ¡ç±»å‹', required: false, type: 'select', options: ['BASIC', 'PREMIUM', 'VIP'] },
                { name: 'STATUS', label: 'çŠ¶æ€', required: false, type: 'select', options: ['ACTIVE', 'INACTIVE', 'SUSPENDED'] }
            ],
            'RMV USER': [
                { name: 'USERNAME', label: 'ç”¨æˆ·å', required: true, placeholder: 'è¦åˆ é™¤çš„ç”¨æˆ·å' }
            ],
            'RMV USR': [
                { name: 'USERNAME', label: 'ç”¨æˆ·å', required: true, placeholder: 'è¦åˆ é™¤çš„ç”¨æˆ·å' }
            ],
            // å¤–å‘¼ç®¡ç†å‘½ä»¤ï¼ˆæŸ¥è¯¢å¤–å‘¼å‘½ä»¤ä¸éœ€è¦å‚æ•°è¡¨å•ï¼‰
            'DSP DIALSVC': [
                // æ— éœ€å‚æ•°è¡¨å•
            ],
            'STR DIALSVC': [
                // æ— éœ€å‚æ•°
            ],
            'STP DIALSVC': [
                // æ— éœ€å‚æ•°
            ],
            'STR CALL SINGLE': [
                { name: 'CALLEE', label: 'è¢«å«å·ç ', required: true, placeholder: 'å¦‚: 1006' },
                { name: 'MEDIA_FILE', label: 'åª’ä½“æ–‡ä»¶', required: false, placeholder: 'ç•™ç©ºä½¿ç”¨é»˜è®¤åª’ä½“æ–‡ä»¶' },
                { name: 'DURATION', label: 'æ’­æ”¾æ—¶é•¿ï¼ˆç§’ï¼‰', required: false, placeholder: '0 è¡¨ç¤ºæ’­æ”¾å®Œæ•´æ–‡ä»¶ï¼Œ>0 è¡¨ç¤ºé™åˆ¶æ’­æ”¾æ—¶é•¿' }
            ],
            'STR CALL BATCH': [
                { name: 'NUMBERS', label: 'è¢«å«å·ç ï¼ˆå·ç èŒƒå›´ï¼‰', required: true, placeholder: 'å¦‚: 1000-1005ï¼Œæ”¯æŒèŒƒå›´æˆ–é€—å·åˆ†éš”ï¼Œå¦‚ 1000-1005 æˆ– 1006,1007,1008' },
                { name: 'MEDIA_FILE', label: 'åª’ä½“æ–‡ä»¶', required: false, placeholder: 'ç•™ç©ºä½¿ç”¨é»˜è®¤åª’ä½“æ–‡ä»¶' },
                { name: 'DURATION', label: 'æ’­æ”¾æ—¶é•¿ï¼ˆç§’ï¼‰', required: false, placeholder: '0 è¡¨ç¤ºæ’­æ”¾å®Œæ•´æ–‡ä»¶ï¼Œ>0 è¡¨ç¤ºé™åˆ¶æ’­æ”¾æ—¶é•¿' }
            ],
            'DSP CALL': [
                // æŸ¥è¯¢å¤–å‘¼ç»Ÿè®¡ä¸éœ€è¦å‚æ•°è¡¨å•ï¼ˆSTAT ç›´æ¥åœ¨å‘½ä»¤ä¸­ï¼‰
            ],
            // å®‰å…¨ç®¡ç†å‘½ä»¤
            'DSP BLACKLIST': [
                // æ— éœ€å‚æ•°
            ],
            'DSP ATTACK': [
                // æ— éœ€å‚æ•°
            ],
            'ADD BLACKLIST': [
                { name: 'IP', label: 'IP åœ°å€', required: true, placeholder: 'å¦‚: 223.165.6.138' }
            ],
            'RMV BLACKLIST': [
                { name: 'IP', label: 'IP åœ°å€', required: true, placeholder: 'å¦‚: 223.165.6.138' }
            ]
        };
        
        // åŠ¨æ€å‚æ•°è¡¨å•åŠŸèƒ½
        function initParamForm() {
            const input = document.getElementById('command-input');
            const paramForm = document.getElementById('param-form');
            const paramFields = document.getElementById('param-form-fields');
            const resizer = document.getElementById('param-form-resizer');
            
            // ç›‘å¬å‘½ä»¤è¾“å…¥å˜åŒ–
            input.addEventListener('input', () => {
                checkAndShowParamForm();
            });
            
            // å‚æ•°è¡¨å•ç°åœ¨ä½¿ç”¨ flex: 1 è‡ªåŠ¨å¡«å……ç©ºé—´ï¼Œä¸å†éœ€è¦ç‹¬ç«‹çš„æ‹–åŠ¨è°ƒæ•´
            // ç”¨æˆ·å¯ä»¥é€šè¿‡æ‹–åŠ¨ input-area é¡¶éƒ¨çš„æ°´å¹³åˆ†éš”æ¡æ¥è°ƒæ•´æ•´ä¸ªè¾“å…¥åŒºåŸŸçš„é«˜åº¦
        }
        
        // æ£€æŸ¥å¹¶æ˜¾ç¤ºå‚æ•°è¡¨å•ï¼ˆç‹¬ç«‹å‡½æ•°ï¼Œå¯ä»¥è¢«å¤šå¤„è°ƒç”¨ï¼‰
        function checkAndShowParamForm() {
            const input = document.getElementById('command-input');
            const paramForm = document.getElementById('param-form');
            const command = input.value.trim().toUpperCase();
            
            // æ£€æŸ¥æ˜¯å¦åŒ¹é…å·²é…ç½®çš„å‘½ä»¤
            let matchedConfig = null;
            for (const [cmdPattern, config] of Object.entries(commandParamConfigs)) {
                if (command.startsWith(cmdPattern)) {
                    matchedConfig = { pattern: cmdPattern, config };
                    break;
                }
            }
            
            if (matchedConfig && matchedConfig.config && matchedConfig.config.length > 0) {
                // æ˜¾ç¤ºå‚æ•°è¡¨å•ï¼ˆåªæœ‰é…ç½®ä¸ä¸ºç©ºæ‰æ˜¾ç¤ºï¼‰
                showParamForm(matchedConfig.pattern, matchedConfig.config);
                
                // ä»å‘½ä»¤æ–‡æœ¬è§£æå·²æœ‰å‚æ•°
                parseCommandToForm(command, matchedConfig.pattern);
            } else {
                // æ²¡æœ‰åŒ¹é…çš„å‘½ä»¤æˆ–é…ç½®ä¸ºç©ºï¼Œéšè—å‚æ•°è¡¨å•
                paramForm.style.display = 'none';
            }
        }
        
        function showParamForm(cmdPattern, config) {
            const paramForm = document.getElementById('param-form');
            const paramFields = document.getElementById('param-form-fields');
            
            // æ¸…ç©ºç°æœ‰å­—æ®µ
            paramFields.innerHTML = '';
            
            // è¿‡æ»¤é‡å¤çš„å­—æ®µåï¼ˆåŒä¸€ä¸ªå­—æ®µåå¯èƒ½å› ä¸ºæ¡ä»¶æ˜¾ç¤ºè€Œå‡ºç°å¤šæ¬¡ï¼‰
            const seenFields = new Set();
            
            // ç”Ÿæˆå‚æ•°è¾“å…¥å­—æ®µ
            config.forEach(field => {
                // è·³è¿‡é‡å¤çš„å­—æ®µåï¼ˆä¿ç•™ç¬¬ä¸€ä¸ªï¼‰
                if (seenFields.has(field.name)) {
                    return;
                }
                seenFields.add(field.name);
                
                const fieldDiv = document.createElement('div');
                fieldDiv.className = 'param-field';
                fieldDiv.dataset.fieldName = field.name;
                
                // ä¿å­˜æ¡ä»¶æ˜¾ç¤ºé…ç½®
                if (field.showIf) {
                    fieldDiv.dataset.showIfField = field.showIf.field;
                    fieldDiv.dataset.showIfValue = field.showIf.value;
                    fieldDiv.style.display = 'none'; // é»˜è®¤éšè—æ¡ä»¶å­—æ®µ
                }
                
                const label = document.createElement('label');
                label.textContent = field.label;
                if (field.required) {
                    const required = document.createElement('span');
                    required.className = 'required';
                    required.textContent = ' *';
                    label.appendChild(required);
                }
                
                let inputElement;
                if (field.type === 'select' && field.options) {
                    inputElement = document.createElement('select');
                    const emptyOption = document.createElement('option');
                    emptyOption.value = '';
                    emptyOption.textContent = '-- è¯·é€‰æ‹© --';
                    inputElement.appendChild(emptyOption);
                    
                    field.options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt;
                        option.textContent = opt;
                        inputElement.appendChild(option);
                    });
                } else {
                    inputElement = document.createElement('input');
                    inputElement.type = field.type || 'text';
                    inputElement.placeholder = field.placeholder || '';
                }
                
                inputElement.dataset.paramName = field.name;
                inputElement.dataset.required = field.required;
                
                // ç›‘å¬å‚æ•°è¾“å…¥å˜åŒ–ï¼Œæ›´æ–°å‘½ä»¤æ–‡æœ¬å’Œæ¡ä»¶å­—æ®µæ˜¾ç¤º
                inputElement.addEventListener('input', () => {
                    updateCommandFromForm(cmdPattern);
                    updateConditionalFields(); // æ›´æ–°æ¡ä»¶å­—æ®µæ˜¾ç¤º
                });
                
                // å¯¹äº selectï¼Œä¹Ÿéœ€è¦ç›‘å¬ change äº‹ä»¶
                if (field.type === 'select') {
                    inputElement.addEventListener('change', () => {
                        updateCommandFromForm(cmdPattern);
                        updateConditionalFields(); // æ›´æ–°æ¡ä»¶å­—æ®µæ˜¾ç¤º
                    });
                }
                
                fieldDiv.appendChild(label);
                fieldDiv.appendChild(inputElement);
                paramFields.appendChild(fieldDiv);
            });
            
            // åˆå§‹åŒ–æ¡ä»¶å­—æ®µæ˜¾ç¤º
            updateConditionalFields();
            
            paramForm.style.display = 'flex';
            
            // å‚æ•°è¡¨å•ç°åœ¨ä½¿ç”¨ flex: 1 è‡ªåŠ¨å¡«å…… input-area å‰©ä½™ç©ºé—´
            // ä¸å†éœ€è¦æ‰‹åŠ¨è®¾ç½®é«˜åº¦ï¼Œoverflow-y: auto ä¼šè‡ªåŠ¨æ˜¾ç¤ºæ»šåŠ¨æ¡
        }
        
        // æ›´æ–°æ¡ä»¶å­—æ®µçš„æ˜¾ç¤º/éšè—
        function updateConditionalFields() {
            const paramFields = document.getElementById('param-form-fields');
            const allFields = paramFields.querySelectorAll('.param-field');
            const inputs = paramFields.querySelectorAll('input, select');
            
            // è·å–æ‰€æœ‰å­—æ®µçš„å½“å‰å€¼
            const fieldValues = {};
            inputs.forEach(input => {
                const fieldName = input.dataset.paramName;
                fieldValues[fieldName] = input.value.trim();
            });
            
            // æ›´æ–°æ¯ä¸ªæ¡ä»¶å­—æ®µçš„æ˜¾ç¤ºçŠ¶æ€
            allFields.forEach(fieldDiv => {
                const showIfField = fieldDiv.dataset.showIfField;
                const showIfValue = fieldDiv.dataset.showIfValue;
                
                if (showIfField && showIfValue) {
                    // æ£€æŸ¥æ¡ä»¶æ˜¯å¦æ»¡è¶³
                    const conditionValue = fieldValues[showIfField] || '';
                    if (conditionValue === showIfValue) {
                        fieldDiv.style.display = 'flex'; // æ˜¾ç¤º
                    } else {
                        fieldDiv.style.display = 'none'; // éšè—
                        // æ¸…é™¤éšè—å­—æ®µçš„å€¼
                        const input = fieldDiv.querySelector('input, select');
                        if (input) {
                            input.value = '';
                        }
                    }
                } else {
                    // æ— æ¡ä»¶å­—æ®µï¼Œé»˜è®¤æ˜¾ç¤º
                    fieldDiv.style.display = 'flex';
                }
            });
        }
        
        function parseCommandToForm(command, cmdPattern) {
            // ä»å‘½ä»¤æ–‡æœ¬è§£æå‚æ•°
            const paramFields = document.getElementById('param-form-fields');
            const inputs = paramFields.querySelectorAll('input, select');
            
            // è§£æå‚æ•°ï¼šUSERNAME=1003 PASSWORD=1003 ç­‰
            const paramRegex = /(\w+)=([^\s]+)/g;
            const params = {};
            let match;
            while ((match = paramRegex.exec(command)) !== null) {
                params[match[1]] = match[2];
            }
            
            // ç‰¹æ®Šå¤„ç† STR CALL SINGLE å’Œ STR CALL BATCHï¼šå·²æ‹†åˆ†ä¸ºç‹¬ç«‹å‘½ä»¤ï¼Œæ— éœ€ç‰¹æ®Šå¤„ç†
            
            // æ›´æ–°è¡¨å•å­—æ®µ
            inputs.forEach(input => {
                const paramName = input.dataset.paramName;
                if (params[paramName]) {
                    input.value = params[paramName];
                }
            });
            
            // æ›´æ–°æ¡ä»¶å­—æ®µæ˜¾ç¤º
            updateConditionalFields();
        }
        
        function updateCommandFromForm(cmdPattern) {
            const paramFields = document.getElementById('param-form-fields');
            const inputs = paramFields.querySelectorAll('input, select');
            const commandInput = document.getElementById('command-input');
            
            // æ”¶é›†å‚æ•°ï¼ˆåªæ”¶é›†å¯è§å­—æ®µçš„å€¼ï¼‰
            const params = [];
            inputs.forEach(input => {
                const paramName = input.dataset.paramName;
                const value = input.value.trim();
                
                // æ£€æŸ¥å­—æ®µæ˜¯å¦å¯è§
                const fieldDiv = input.closest('.param-field');
                if (fieldDiv && fieldDiv.style.display !== 'none' && value) {
                    // æ‰€æœ‰å­—æ®µç›´æ¥è¾“å‡ºåˆ°å‘½ä»¤ä¸­
                    params.push(`${paramName}=${value}`);
                }
            });
            
            // æ›´æ–°å‘½ä»¤æ–‡æœ¬
            let newCommand = cmdPattern;
            if (params.length > 0) {
                newCommand += ' ' + params.join(' ');
            }
            
            commandInput.value = newCommand;
        }
        
        // å‘½ä»¤è‡ªåŠ¨è¡¥å…¨åŠŸèƒ½
        function initAutocomplete() {
            const input = document.getElementById('command-input');
            const dropdown = document.getElementById('autocomplete-dropdown');
            
            input.addEventListener('input', () => {
                const value = input.value.trim().toUpperCase();
                
                if (value.length === 0) {
                    dropdown.style.display = 'none';
                    autocompleteIndex = -1;
                    return;
                }
                
                // æŸ¥æ‰¾åŒ¹é…çš„å‘½ä»¤
                const matches = allCommands.filter(cmd => {
                    return cmd.command.toUpperCase().includes(value) ||
                           cmd.name.toUpperCase().includes(value);
                }).slice(0, 10);  // æœ€å¤šæ˜¾ç¤º10ä¸ª
                
                if (matches.length === 0) {
                    dropdown.style.display = 'none';
                    autocompleteIndex = -1;
                    return;
                }
                
                // æ¸²æŸ“åŒ¹é…ç»“æœ
                dropdown.innerHTML = '';
                matches.forEach((cmd, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.innerHTML = `
                        <span class="command-name">${cmd.command}</span>
                        <span class="command-desc">${cmd.name} - ${cmd.category}</span>
                    `;
                    
                    item.addEventListener('click', () => {
                        input.value = cmd.command;
                        dropdown.style.display = 'none';
                        autocompleteIndex = -1;
                        input.focus();
                    });
                    
                    dropdown.appendChild(item);
                });
                
                dropdown.style.display = 'block';
                autocompleteIndex = -1;
            });
            
            // é”®ç›˜å¯¼èˆª
            input.addEventListener('keydown', (e) => {
                const items = dropdown.querySelectorAll('.autocomplete-item');
                
                if (e.key === 'Tab') {
                    e.preventDefault();
                    // Tab è¡¥å…¨ï¼šå¦‚æœæœ‰åŒ¹é…é¡¹ï¼Œè¡¥å…¨ç¬¬ä¸€ä¸ª
                    if (items.length > 0) {
                        if (autocompleteIndex >= 0) {
                            items[autocompleteIndex].click();
                        } else {
                            items[0].click();
                        }
                    } else {
                        // å°è¯•å‚æ•°è¡¥å…¨
                        doParamAutocomplete(input);
                    }
                    return;
                }
                
                if (items.length === 0) {
                    // æ²¡æœ‰ä¸‹æ‹‰èœå•æ—¶ï¼Œä¹Ÿå¤„ç†ä¸Šä¸‹é”®å†å²è®°å½•
                    if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                        // è®©äº‹ä»¶å†’æ³¡åˆ°å†å²è®°å½•å¤„ç†
                        return;
                    }
                    return;
                }
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    autocompleteIndex = Math.min(autocompleteIndex + 1, items.length - 1);
                    updateAutocompleteSelection(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    autocompleteIndex = Math.max(autocompleteIndex - 1, -1);
                    updateAutocompleteSelection(items);
                } else if (e.key === 'Enter' && autocompleteIndex >= 0) {
                    e.preventDefault();
                    items[autocompleteIndex].click();
                } else if (e.key === 'Escape') {
                    dropdown.style.display = 'none';
                    autocompleteIndex = -1;
                }
            });
            
            // å‚æ•°è¡¥å…¨åŠŸèƒ½
            function doParamAutocomplete(input) {
                const value = input.value.trim().toUpperCase();
                const cursorPos = input.selectionStart;
                
                // æŸ¥æ‰¾å½“å‰å‘½ä»¤çš„å‚æ•°é…ç½®
                for (const [cmdPattern, config] of Object.entries(commandParamConfigs)) {
                    if (value.startsWith(cmdPattern)) {
                        // æ‰¾åˆ°åŒ¹é…çš„å‘½ä»¤ï¼Œæç¤ºä¸‹ä¸€ä¸ªå‚æ•°
                        const existingParams = value.substring(cmdPattern.length).trim();
                        const existingKeys = new Set();
                        
                        // è§£æå·²æœ‰çš„å‚æ•°
                        const paramRegex = /(\w+)=/g;
                        let match;
                        while ((match = paramRegex.exec(existingParams)) !== null) {
                            existingKeys.add(match[1]);
                        }
                        
                        // æ‰¾åˆ°ç¬¬ä¸€ä¸ªæœªå¡«å†™çš„å¿…å¡«å‚æ•°
                        for (const field of config) {
                            if (field.required && !existingKeys.has(field.name)) {
                                // æ’å…¥å‚æ•°æ¨¡æ¿
                                const insertText = `${field.name}=`;
                                const newValue = value + (value.endsWith(' ') ? '' : ' ') + insertText;
                                input.value = newValue;
                                // å°†å…‰æ ‡æ”¾åˆ°ç­‰å·åé¢
                                setTimeout(() => {
                                    input.setSelectionRange(newValue.length, newValue.length);
                                    input.focus();
                                }, 0);
                                return;
                            }
                        }
                        
                        // æ‰€æœ‰å¿…å¡«å‚æ•°éƒ½æœ‰äº†ï¼Œæç¤ºå¯é€‰å‚æ•°
                        for (const field of config) {
                            if (!field.required && !existingKeys.has(field.name)) {
                                const insertText = `${field.name}=`;
                                const newValue = value + (value.endsWith(' ') ? '' : ' ') + insertText;
                                input.value = newValue;
                                setTimeout(() => {
                                    input.setSelectionRange(newValue.length, newValue.length);
                                    input.focus();
                                }, 0);
                                return;
                            }
                        }
                        
                        break;
                    }
                }
            };
            
            // ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰æ¡†
            document.addEventListener('click', (e) => {
                if (!input.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.style.display = 'none';
                    autocompleteIndex = -1;
                }
            });
        }
        
        function updateAutocompleteSelection(items) {
            items.forEach((item, index) => {
                if (index === autocompleteIndex) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('selected');
                }
            });
        }
        
        // åˆå§‹åŒ–
        // é¡µç­¾åˆ‡æ¢
        let mediaEndpointsIntervalId = null;

        function initOutputTabs() {
            const currentTab = document.getElementById('current-tab');
            const historyTab = document.getElementById('history-tab');
            const sipMessagesTab = document.getElementById('sip-messages-tab');
            const mediaEndpointsTab = document.getElementById('media-endpoints-tab');
            const outputContent = document.getElementById('output-content');
            const historyContent = document.getElementById('history-content');
            const sipMessagesContent = document.getElementById('sip-messages-content');
            const mediaEndpointsContent = document.getElementById('media-endpoints-content');
            
            function setActiveTab(active) {
                [currentTab, historyTab, sipMessagesTab, mediaEndpointsTab].forEach(t => t.classList.remove('active'));
                active.classList.add('active');
                outputContent.style.display = active === currentTab ? 'block' : 'none';
                historyContent.style.display = active === historyTab ? 'flex' : 'none';
                sipMessagesContent.style.display = active === sipMessagesTab ? 'flex' : 'none';
                mediaEndpointsContent.style.display = active === mediaEndpointsTab ? 'flex' : 'none';
                if (sipMessagesPollIntervalId) { clearInterval(sipMessagesPollIntervalId); sipMessagesPollIntervalId = null; }
                if (mediaEndpointsIntervalId) { clearInterval(mediaEndpointsIntervalId); mediaEndpointsIntervalId = null; }
            }
            
            currentTab.addEventListener('click', () => {
                setActiveTab(currentTab);
                // æ¢å¤ MML è¾“å…¥åŒºå’Œè¡¥å…¨æ¡†
                const inputArea = document.getElementById('input-area');
                const paramForm = document.getElementById('param-form');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                if (inputArea) {
                    inputArea.style.display = '';
                    inputArea.style.height = '';
                    inputArea.style.minHeight = '';
                    inputArea.style.maxHeight = '';
                    inputArea.style.padding = '';
                    inputArea.style.margin = '';
                }
                if (paramForm) {
                    paramForm.style.display = '';  // ç”± checkAndShowParamForm æ§åˆ¶æ˜¾ç¤º
                    paramForm.style.height = '';
                    paramForm.style.minHeight = '';
                    paramForm.style.maxHeight = '';
                }
                if (horizontalResizer) {
                    horizontalResizer.style.display = '';
                    horizontalResizer.style.height = '';
                    horizontalResizer.style.margin = '';
                }
            });
            
            historyTab.addEventListener('click', () => {
                setActiveTab(historyTab);
                const inputArea = document.getElementById('input-area');
                const paramForm = document.getElementById('param-form');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                if (inputArea) {
                    inputArea.style.display = '';
                    inputArea.style.height = '';
                    inputArea.style.minHeight = '';
                    inputArea.style.maxHeight = '';
                    inputArea.style.padding = '';
                    inputArea.style.margin = '';
                }
                if (paramForm) {
                    paramForm.style.display = '';
                    paramForm.style.height = '';
                    paramForm.style.minHeight = '';
                    paramForm.style.maxHeight = '';
                }
                if (horizontalResizer) {
                    horizontalResizer.style.display = '';
                    horizontalResizer.style.height = '';
                    horizontalResizer.style.margin = '';
                }
            });
            
            sipMessagesTab.addEventListener('click', () => {
                setActiveTab(sipMessagesTab);
                const inputArea = document.getElementById('input-area');
                const paramForm = document.getElementById('param-form');
                const autocompleteDropdown = document.getElementById('autocomplete-dropdown');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                if (inputArea) {
                    inputArea.style.display = 'none';
                    inputArea.style.height = '0';
                    inputArea.style.minHeight = '0';
                    inputArea.style.maxHeight = '0';
                    inputArea.style.padding = '0';
                    inputArea.style.margin = '0';
                }
                if (paramForm) {
                    paramForm.style.display = 'none';
                    paramForm.style.height = '0';
                    paramForm.style.minHeight = '0';
                    paramForm.style.maxHeight = '0';
                }
                if (autocompleteDropdown) {
                    autocompleteDropdown.style.display = 'none';
                }
                if (horizontalResizer) {
                    horizontalResizer.style.display = 'none';
                    horizontalResizer.style.height = '0';
                    horizontalResizer.style.margin = '0';
                }
                loadSipMessages();
                // å¯åŠ¨è½®è¯¢ï¼šè¡¥å…¨ WebSocket å»¶è¿Ÿ/æ¼æ¨çš„æ¶ˆæ¯ï¼ˆå¦‚ re-INVITE 200 çš„ ACK FWDï¼‰
                if (sipMessagesPollIntervalId) clearInterval(sipMessagesPollIntervalId);
                sipMessagesPollIntervalId = setInterval(() => {
                    if (sipMessagesPaused) return;
                    loadSipMessages();
                }, 3000);
                
                // æ·»åŠ æ»šåŠ¨äº‹ä»¶ç›‘å¬å™¨ï¼Œæ£€æµ‹ç”¨æˆ·æ‰‹åŠ¨æ»šåŠ¨
                const scrollWrapper = document.querySelector('.sip-messages-table-scroll-wrapper');
                if (scrollWrapper) {
                    scrollWrapper.removeEventListener('scroll', handleSipMessagesScroll);
                    scrollWrapper.addEventListener('scroll', handleSipMessagesScroll);
                }
            });

            mediaEndpointsTab.addEventListener('click', () => {
                setActiveTab(mediaEndpointsTab);
                const inputArea = document.getElementById('input-area');
                const paramForm = document.getElementById('param-form');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                if (inputArea) {
                    inputArea.style.display = 'none';
                    inputArea.style.height = '0';
                    inputArea.style.minHeight = '0';
                    inputArea.style.maxHeight = '0';
                    inputArea.style.padding = '0';
                    inputArea.style.margin = '0';
                }
                if (paramForm) { paramForm.style.display = 'none'; paramForm.style.height = '0'; }
                if (horizontalResizer) { horizontalResizer.style.display = 'none'; horizontalResizer.style.height = '0'; }
                loadMediaEndpoints();
                const autoRefresh = document.getElementById('media-endpoints-auto-refresh');
                if (mediaEndpointsIntervalId) clearInterval(mediaEndpointsIntervalId);
                if (autoRefresh && autoRefresh.checked) {
                    mediaEndpointsIntervalId = setInterval(loadMediaEndpoints, 2000);
                }
            });
        }

        async function loadMediaEndpoints() {
            const summaryEl = document.getElementById('media-endpoints-summary');
            const diagEl = document.getElementById('media-endpoints-diagnosis');
            const sessionsEl = document.getElementById('media-endpoints-sessions');
            if (!summaryEl || !diagEl || !sessionsEl) return;
            try {
                const res = await fetch('/api/media-endpoints');
                const data = await res.json();
                if (!data.success) {
                    summaryEl.textContent = 'åŠ è½½å¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯');
                    diagEl.textContent = '';
                    diagEl.className = 'media-endpoints-diagnosis err';
                    sessionsEl.innerHTML = '<div class="empty">æ— æ•°æ®</div>';
                    return;
                }
                const relayType = data.relay_type === 'rtpproxy' ? 'RTPProxy' : (data.relay_type === 'custom' ? 'è‡ªå®šä¹‰è½¬å‘å™¨' : 'æ— ');
                const portStats = data.port_stats || {};
                summaryEl.textContent = `ä¸­ç»§: ${relayType} | æœåŠ¡å™¨: ${data.server_ip || 'N/A'} | æ´»è·ƒä¼šè¯: ${(data.sessions || []).length} | ç«¯å£å¯¹: å·²ç”¨ ${portStats.used_pairs ?? '-'} / æ€» ${portStats.total_pairs ?? '-'}`;
                diagEl.textContent = data.diagnosis_summary || '';
                diagEl.className = 'media-endpoints-diagnosis' + (data.diagnosis_summary && (data.diagnosis_summary.indexOf('å¼‚å¸¸') >= 0 || data.diagnosis_summary.indexOf('æœª') >= 0) ? ' warn' : '');
                const sessions = data.sessions || [];
                if (sessions.length === 0) {
                    sessionsEl.innerHTML = '<div class="empty">å½“å‰æ— åª’ä½“ä¼šè¯</div>';
                    return;
                }
                sessionsEl.innerHTML = sessions.map(s => {
                    const audio = s.audio || {};
                    const aA = audio.a_leg || {}, aB = audio.b_leg || {};
                    const audioStats = audio.stats || {};
                    const video = s.video;
                    const videoStats = video?.stats;
                    
                    let rows = [];
                    
                    // éŸ³é¢‘ç»Ÿè®¡ - ä¸»å«ï¼ˆä¸Šè¡Œï¼‰ï¼Œæ‹†æˆä¸¤æ®µï¼šä¸»å«â†’æœåŠ¡å™¨ å’Œ æœåŠ¡å™¨â†’è¢«å«
                    const audioUplink = audioStats.uplink || {};
                    const callerToServer = audioUplink.caller_to_server || {};
                    const serverToCallee = audioUplink.server_to_callee || {};
                    const callerToServerRtp = callerToServer.rtp ?? 0;
                    const callerToServerRtcp = callerToServer.rtcp ?? 0;
                    const serverToCalleeRtp = serverToCallee.rtp ?? 0;
                    const serverToCalleeRtcp = serverToCallee.rtcp ?? 0;
                    const callerToServerClass = callerToServerRtp > 0 ? 'media-stat-good' : 'media-stat-zero';
                    const serverToCalleeClass = serverToCalleeRtp > 0 ? 'media-stat-good' : 'media-stat-zero';
                    rows.push(`<tr class="media-label-uplink">
                        <th><span class="media-label-caller">ä¸»å«</span> â†’ <span class="media-label-callee">è¢«å«</span> <span class="media-label-audio">(éŸ³é¢‘ä¸Šè¡Œ)</span></th>
                        <td>
                            <div style="display: flex; gap: 15px;">
                                <span><span class="media-label-caller">ä¸»å«â†’æœåŠ¡å™¨</span>: RTP <span class="${callerToServerClass}">${callerToServerRtp}</span> / RTCP <span class="${callerToServerRtcp > 0 ? 'media-stat-good' : 'media-stat-zero'}">${callerToServerRtcp}</span></span>
                                <span><span class="media-label-callee">æœåŠ¡å™¨â†’è¢«å«</span>: RTP <span class="${serverToCalleeClass}">${serverToCalleeRtp}</span> / RTCP <span class="${serverToCalleeRtcp > 0 ? 'media-stat-good' : 'media-stat-zero'}">${serverToCalleeRtcp}</span></span>
                            </div>
                        </td>
                        <td>A-leg: ${aA.rtp_port ?? '-'}/${aA.rtcp_port ?? '-'} â†’ B-leg: ${aB.rtp_port ?? '-'}/${aB.rtcp_port ?? '-'}</td>
                    </tr>`);
                    
                    // éŸ³é¢‘ç»Ÿè®¡ - è¢«å«ï¼ˆä¸‹è¡Œï¼‰ï¼Œæ‹†æˆä¸¤æ®µï¼šè¢«å«â†’æœåŠ¡å™¨ å’Œ æœåŠ¡å™¨â†’ä¸»å«
                    const audioDownlink = audioStats.downlink || {};
                    const calleeToServer = audioDownlink.callee_to_server || {};
                    const serverToCaller = audioDownlink.server_to_caller || {};
                    const calleeToServerRtp = calleeToServer.rtp ?? 0;
                    const calleeToServerRtcp = calleeToServer.rtcp ?? 0;
                    const serverToCallerRtp = serverToCaller.rtp ?? 0;
                    const serverToCallerRtcp = serverToCaller.rtcp ?? 0;
                    const calleeToServerClass = calleeToServerRtp > 0 ? 'media-stat-good' : 'media-stat-zero';
                    const serverToCallerClass = serverToCallerRtp > 0 ? 'media-stat-good' : 'media-stat-zero';
                    rows.push(`<tr class="media-label-downlink">
                        <th><span class="media-label-callee">è¢«å«</span> â†’ <span class="media-label-caller">ä¸»å«</span> <span class="media-label-audio">(éŸ³é¢‘ä¸‹è¡Œ)</span></th>
                        <td>
                            <div style="display: flex; gap: 15px;">
                                <span><span class="media-label-callee">è¢«å«â†’æœåŠ¡å™¨</span>: RTP <span class="${calleeToServerClass}">${calleeToServerRtp}</span> / RTCP <span class="${calleeToServerRtcp > 0 ? 'media-stat-good' : 'media-stat-zero'}">${calleeToServerRtcp}</span></span>
                                <span><span class="media-label-caller">æœåŠ¡å™¨â†’ä¸»å«</span>: RTP <span class="${serverToCallerClass}">${serverToCallerRtp}</span> / RTCP <span class="${serverToCallerRtcp > 0 ? 'media-stat-good' : 'media-stat-zero'}">${serverToCallerRtcp}</span></span>
                            </div>
                        </td>
                        <td>B-leg: ${aB.rtp_port ?? '-'}/${aB.rtcp_port ?? '-'} â†’ A-leg: ${aA.rtp_port ?? '-'}/${aA.rtcp_port ?? '-'}</td>
                    </tr>`);
                    
                    // è§†é¢‘ç»Ÿè®¡ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                    if (video && (video.a_leg || video.b_leg)) {
                        const vA = video.a_leg || {}, vB = video.b_leg || {};
                        
                        // è§†é¢‘ä¸Šè¡Œï¼ˆä¸»å«â†’è¢«å«ï¼‰ï¼Œæ‹†æˆä¸¤æ®µï¼šä¸»å«â†’æœåŠ¡å™¨ å’Œ æœåŠ¡å™¨â†’è¢«å«
                        const videoUplink = videoStats?.uplink || {};
                        const videoCallerToServer = videoUplink.caller_to_server || {};
                        const videoServerToCallee = videoUplink.server_to_callee || {};
                        const videoCallerToServerRtp = videoCallerToServer.rtp ?? 0;
                        const videoCallerToServerRtcp = videoCallerToServer.rtcp ?? 0;
                        const videoServerToCalleeRtp = videoServerToCallee.rtp ?? 0;
                        const videoServerToCalleeRtcp = videoServerToCallee.rtcp ?? 0;
                        const videoCallerToServerClass = videoCallerToServerRtp > 0 ? 'media-stat-good' : 'media-stat-zero';
                        const videoServerToCalleeClass = videoServerToCalleeRtp > 0 ? 'media-stat-good' : 'media-stat-zero';
                        rows.push(`<tr class="media-label-uplink">
                            <th><span class="media-label-caller">ä¸»å«</span> â†’ <span class="media-label-callee">è¢«å«</span> <span class="media-label-video">(è§†é¢‘ä¸Šè¡Œ)</span></th>
                            <td>
                                <div style="display: flex; gap: 15px;">
                                    <span><span class="media-label-caller">ä¸»å«â†’æœåŠ¡å™¨</span>: RTP <span class="${videoCallerToServerClass}">${videoCallerToServerRtp}</span> / RTCP <span class="${videoCallerToServerRtcp > 0 ? 'media-stat-good' : 'media-stat-zero'}">${videoCallerToServerRtcp}</span></span>
                                    <span><span class="media-label-callee">æœåŠ¡å™¨â†’è¢«å«</span>: RTP <span class="${videoServerToCalleeClass}">${videoServerToCalleeRtp}</span> / RTCP <span class="${videoServerToCalleeRtcp > 0 ? 'media-stat-good' : 'media-stat-zero'}">${videoServerToCalleeRtcp}</span></span>
                                </div>
                            </td>
                            <td>A-leg: ${vA.rtp_port ?? '-'}/${vA.rtcp_port ?? '-'} â†’ B-leg: ${vB.rtp_port ?? '-'}/${vB.rtcp_port ?? '-'}</td>
                        </tr>`);
                        
                        // è§†é¢‘ä¸‹è¡Œï¼ˆè¢«å«â†’ä¸»å«ï¼‰ï¼Œæ‹†æˆä¸¤æ®µï¼šè¢«å«â†’æœåŠ¡å™¨ å’Œ æœåŠ¡å™¨â†’ä¸»å«
                        const videoDownlink = videoStats?.downlink || {};
                        const videoCalleeToServer = videoDownlink.callee_to_server || {};
                        const videoServerToCaller = videoDownlink.server_to_caller || {};
                        const videoCalleeToServerRtp = videoCalleeToServer.rtp ?? 0;
                        const videoCalleeToServerRtcp = videoCalleeToServer.rtcp ?? 0;
                        const videoServerToCallerRtp = videoServerToCaller.rtp ?? 0;
                        const videoServerToCallerRtcp = videoServerToCaller.rtcp ?? 0;
                        const videoCalleeToServerClass = videoCalleeToServerRtp > 0 ? 'media-stat-good' : 'media-stat-zero';
                        const videoServerToCallerClass = videoServerToCallerRtp > 0 ? 'media-stat-good' : 'media-stat-zero';
                        rows.push(`<tr class="media-label-downlink">
                            <th><span class="media-label-callee">è¢«å«</span> â†’ <span class="media-label-caller">ä¸»å«</span> <span class="media-label-video">(è§†é¢‘ä¸‹è¡Œ)</span></th>
                            <td>
                                <div style="display: flex; gap: 15px;">
                                    <span><span class="media-label-callee">è¢«å«â†’æœåŠ¡å™¨</span>: RTP <span class="${videoCalleeToServerClass}">${videoCalleeToServerRtp}</span> / RTCP <span class="${videoCalleeToServerRtcp > 0 ? 'media-stat-good' : 'media-stat-zero'}">${videoCalleeToServerRtcp}</span></span>
                                    <span><span class="media-label-caller">æœåŠ¡å™¨â†’ä¸»å«</span>: RTP <span class="${videoServerToCallerClass}">${videoServerToCallerRtp}</span> / RTCP <span class="${videoServerToCallerRtcp > 0 ? 'media-stat-good' : 'media-stat-zero'}">${videoServerToCallerRtcp}</span></span>
                                </div>
                            </td>
                            <td>B-leg: ${vB.rtp_port ?? '-'}/${vB.rtcp_port ?? '-'} â†’ A-leg: ${vA.rtp_port ?? '-'}/${vA.rtcp_port ?? '-'}</td>
                        </tr>`);
                    }
                    
                    const diagClass = (s.diagnosis && (s.diagnosis.indexOf('æœª') >= 0 || s.diagnosis.indexOf('å¼‚å¸¸') >= 0)) ? '' : ' ok';
                    const audioDrops = s.audio_drops || {};
                    const videoDrops = s.video_drops || {};
                    const dropText = [];
                    if ((audioDrops.uplink || 0) + (audioDrops.downlink || 0) > 0) dropText.push('éŸ³é¢‘ä¸¢åŒ…:' + ((audioDrops.uplink || 0) + (audioDrops.downlink || 0)));
                    if ((videoDrops.uplink || 0) + (videoDrops.downlink || 0) > 0) dropText.push('è§†é¢‘ä¸¢åŒ…:' + ((videoDrops.uplink || 0) + (videoDrops.downlink || 0)));
                    const dropLine = dropText.length ? '<div class="diagnosis" style="margin-top:4px;">è½¬å‘å¡é¡¿: ' + dropText.join('; ') + '</div>' : '';
                    const callId = s.call_id;
                    const hasAudio = s.audio && (s.audio.a_leg || s.audio.b_leg);
                    const hasVideo = s.video && (s.video.a_leg || s.video.b_leg);
                    
                    // ç›‘å¬æŒ‰é’®ï¼šä¸€ä¸ªæŒ‰é’®æ‰“å¼€ä¸»è¢«å«éŸ³è§†é¢‘ï¼Œçª—å£å†…å¯å•ç‹¬é™éŸ³
                    const hasAny = hasAudio || hasVideo;
                    const monitorBtn = hasAny
                        ? `<button class="monitor-btn monitor-btn-single" data-call-id="${callId}" data-has-audio="${!!hasAudio}" data-has-video="${!!hasVideo}" title="ç›‘å¬ä¸»è¢«å«éŸ³è§†é¢‘">ğŸ§ ç›‘å¬</button>`
                        : '';
                    
                    return `<div class="media-session-card">
                        <h4><span class="media-label-caller">${s.caller}</span> â†’ <span class="media-label-callee">${s.callee}</span> (${s.call_id}) ${s.duration_sec != null ? ' Â· ' + s.duration_sec + 's' : ''}</h4>
                        <table class="media-ports"><tbody>${rows.join('')}</tbody></table>
                        <div class="diagnosis${diagClass}">${s.diagnosis || 'æ­£å¸¸'}</div>
                        ${dropLine}
                        ${monitorBtn ? `<div class="monitor-buttons">${monitorBtn}</div>` : ''}
                    </div>`;
                }).join('');
            } catch (e) {
                summaryEl.textContent = 'è¯·æ±‚å¤±è´¥: ' + e.message;
                diagEl.textContent = '';
                sessionsEl.innerHTML = '<div class="empty">åŠ è½½å¤±è´¥</div>';
            }
        }

        document.getElementById('media-endpoints-refresh-btn')?.addEventListener('click', loadMediaEndpoints);
        document.getElementById('media-endpoints-auto-refresh')?.addEventListener('change', function() {
            if (mediaEndpointsIntervalId) { clearInterval(mediaEndpointsIntervalId); mediaEndpointsIntervalId = null; }
            const mediaEndpointsContent = document.getElementById('media-endpoints-content');
            if (this.checked && mediaEndpointsContent && mediaEndpointsContent.style.display === 'flex') {
                mediaEndpointsIntervalId = setInterval(loadMediaEndpoints, 2000);
            }
        });
        
        // åª’ä½“æµç›‘å¬åŠŸèƒ½ï¼ˆå››è·¯ï¼šä¸»å«/è¢«å« éŸ³é¢‘/è§†é¢‘ï¼Œä¸€ä¸ªæŒ‰é’®æ‰“å¼€ï¼Œå¯å•ç‹¬é™éŸ³ï¼‰
        let mediaMonitorWebSocket = null;  // å…¼å®¹å•è·¯æ—§é€»è¾‘
        let mediaMonitorWebSockets = {};  // streamType -> WebSocket
        let currentMonitorCallId = null;
        let currentMonitorStreamType = null;
        const mediaMonitorStats = { packetsReceived: 0, packetsSent: 0, totalBytes: 0, lastPacketSize: 0, packetsDropped: 0 };
        const mediaMonitorStreamStats = {};  // streamType -> { packetsReceived, packetsSent, totalBytes, packetsDropped }
        let mediaMonitorMute = { 'audio-a': false, 'audio-b': false, 'video-a': false, 'video-b': false };  // é™éŸ³çŠ¶æ€
        
        // ç›‘å¬æŒ‰é’®ç‚¹å‡»äº‹ä»¶ï¼ˆäº‹ä»¶å§”æ‰˜ï¼‰ï¼šä¸€ä¸ªæŒ‰é’®æ‰“å¼€ä¸»è¢«å«éŸ³è§†é¢‘å››è·¯
        document.addEventListener('click', (e) => {
            if (!e.target.classList.contains('monitor-btn')) return;
            const callId = e.target.dataset.callId;
            const isSingle = e.target.classList.contains('monitor-btn-single');
            
            if (isSingle) {
                // ä¸€ä¸ªæŒ‰é’®ï¼šæ‰“å¼€çª—å£å¹¶è¿æ¥ä¸»è¢«å«éŸ³è§†é¢‘å››è·¯
                const hasAudio = e.target.dataset.hasAudio === 'true';
                const hasVideo = e.target.dataset.hasVideo === 'true';
                const isActive = e.target.classList.contains('active');
                if (isActive) {
                    closeMediaMonitorWindow();
                    e.target.classList.remove('active');
                } else {
                    document.querySelectorAll('.monitor-btn.active').forEach(btn => btn.classList.remove('active'));
                    startMediaMonitorAll(callId, hasAudio, hasVideo);
                    e.target.classList.add('active');
                }
                return;
            }
            // å…¼å®¹æ—§ç‰ˆå¤šæŒ‰é’®ï¼ˆè‹¥æœ‰æ®‹ç•™ï¼‰
            const streamType = e.target.dataset.streamType;
            if (!streamType) return;
            const isActive = e.target.classList.contains('active');
            if (isActive) {
                stopAllMediaMonitorWebSockets();
                currentMonitorCallId = null;
                updateMonitorStatus('æœªè¿æ¥', '');
                e.target.classList.remove('active');
            } else {
                document.querySelectorAll('.monitor-btn.active').forEach(btn => btn.classList.remove('active'));
                startMediaMonitor(callId, streamType);
                e.target.classList.add('active');
            }
        });
        
        function stopAllMediaMonitorWebSockets() {
            [...Object.entries(mediaMonitorWebSockets)].forEach(([st, ws]) => {
                if (!ws) return;
                ws.onopen = null; ws.onmessage = null; ws.onerror = null; ws.onclose = null;
                try { if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) ws.close(); } catch (e) {}
            });
            mediaMonitorWebSockets = {};
            if (mediaMonitorWebSocket) {
                mediaMonitorWebSocket.onopen = null; mediaMonitorWebSocket.onmessage = null;
                mediaMonitorWebSocket.onerror = null; mediaMonitorWebSocket.onclose = null;
                try { if (mediaMonitorWebSocket.readyState === WebSocket.OPEN || mediaMonitorWebSocket.readyState === WebSocket.CONNECTING) mediaMonitorWebSocket.close(); } catch (e) {}
                mediaMonitorWebSocket = null;
            }
        }
        
        function closeMediaMonitorWindow() {
            stopAllMediaMonitorWebSockets();
            cleanupMediaPlayer();
            currentMonitorCallId = null;
            currentMonitorStreamType = null;
            updateMonitorStatus('æœªè¿æ¥', '');
            document.getElementById('media-monitor-window').classList.remove('active');
            document.querySelectorAll('.monitor-btn.active').forEach(btn => btn.classList.remove('active'));
        }
        
        // å…³é—­ç›‘å¬çª—å£
        document.getElementById('media-monitor-close')?.addEventListener('click', () => {
            closeMediaMonitorWindow();
        });
        
        let connectionTimeoutId = null;
        
        function getMediaMonitorWsBaseUrl() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsHostname = window.location.hostname === '0.0.0.0' ? 'localhost' : window.location.hostname;
            const httpPort = window.location.port ? parseInt(window.location.port) : (window.location.protocol === 'https:' ? 443 : 80);
            const isCloudflareTunnel = window.location.hostname.includes('trycloudflare.com');
            const wsPort = isCloudflareTunnel ? httpPort : ((httpPort === 80 || httpPort === 443) ? 8889 : (httpPort + 1));
            return `${wsProtocol}//${wsHostname}:${wsPort}`;
        }
        
        function startMediaMonitorAll(callId, hasAudio, hasVideo) {
            stopAllMediaMonitorWebSockets();
            currentMonitorCallId = callId;
            const streams = [];
            if (hasAudio) streams.push('audio-a', 'audio-b');
            if (hasVideo) streams.push('video-a', 'video-b');
            ['audio-a','audio-b','video-a','video-b'].forEach(st => {
                mediaMonitorStreamStats[st] = { packetsReceived: 0, packetsSent: 0, totalBytes: 0, packetsDropped: 0 };
            });
            mediaMonitorStats.packetsReceived = 0;
            mediaMonitorStats.packetsSent = 0;
            mediaMonitorStats.totalBytes = 0;
            mediaMonitorStats.packetsDropped = 0;
            updateMonitorStats();
            document.getElementById('media-monitor-title').textContent = `åª’ä½“æµç›‘å¬: ${callId.substring(0, 20)}... (ä¸»è¢«å«éŸ³è§†é¢‘)`;
            document.getElementById('media-monitor-window').classList.add('active');
            updateMonitorStatus('è¿æ¥ä¸­...', '');
            // é¢æ¿åˆå§‹çŠ¶æ€ï¼ˆè§†é¢‘é¢æ¿çš„ body å†…å« canvasï¼Œä¸èƒ½è®¾ textContent å¦åˆ™ä¼šæ¸…ç©ºç”»å¸ƒï¼‰
            ['audio-a','audio-b','video-a','video-b'].forEach(st => {
                const body = document.getElementById('panel-body-' + st);
                const info = document.getElementById('info-' + st);
                if (st.startsWith('audio')) {
                    if (body) body.textContent = streams.indexOf(st) >= 0 ? 'è¿æ¥ä¸­â€¦' : 'â€”';
                } else {
                    if (info) info.textContent = streams.indexOf(st) >= 0 ? 'è¿æ¥ä¸­â€¦' : 'â€”';
                }
            });
            // é™éŸ³å¤é€‰æ¡†ç»‘å®š
            ['audio-a','audio-b','video-a','video-b'].forEach(st => {
                const cb = document.getElementById('mute-' + st);
                if (cb) {
                    cb.checked = mediaMonitorMute[st] || false;
                    cb.onchange = () => {
                        mediaMonitorMute[st] = cb.checked;
                        if (st.startsWith('audio')) applyAudioMute(st, cb.checked);
                        if (st.startsWith('video')) applyVideoMute(st, cb.checked);
                    };
                }
            });
            initMediaPlayerMultiStream(streams);
            const baseUrl = getMediaMonitorWsBaseUrl();
            let connectedCount = 0;
            streams.forEach(streamType => {
                const wsUrl = `${baseUrl}/ws/media-stream?call_id=${encodeURIComponent(callId)}&stream_type=${encodeURIComponent(streamType)}`;
                try {
                    const ws = new WebSocket(wsUrl);
                    mediaMonitorWebSockets[streamType] = ws;
                    ws.onopen = () => {
                        connectedCount++;
                        if (streamType.startsWith('audio')) {
                            const body = document.getElementById('panel-body-' + streamType);
                            if (body) body.textContent = 'æ’­æ”¾ä¸­';
                        } else {
                            const info = document.getElementById('info-' + streamType);
                            if (info) info.textContent = 'è§£ç ä¸­â€¦';
                        }
                        updateMonitorStatus(connectedCount === streams.length ? 'ç›‘å¬ä¸­â€¦' : `è¿æ¥ä¸­ (${connectedCount}/${streams.length})â€¦`, 'connected');
                    };
                    ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            if (data.type === 'connected') {
                                if (streamType.startsWith('audio')) {
                                    const body = document.getElementById('panel-body-' + streamType);
                                    if (body) body.textContent = 'æ’­æ”¾ä¸­';
                                } else {
                                    // è§†é¢‘ï¼šä¸è¦†ç›–å·²æœ‰ MSE çŠ¶æ€ï¼ˆmse_init/mse_fragment ä¼šè®¾ç½®ã€Œå·²å°±ç»ªã€ã€Œå·²è§£ç  n å¸§ã€ï¼‰
                                    const info = document.getElementById('info-' + streamType);
                                    if (info && !info.textContent) info.textContent = 'è§£ç ä¸­â€¦';
                                }
                            } else if (data.type === 'mse_init') {
                                if (streamType.startsWith('video') && data.data) initMSEForStreamWithBackendInit(streamType, data.data, data.codec);
                            } else if (data.type === 'mse_fragment') {
                                if (streamType.startsWith('video') && data.data) appendMSEFragmentBytes(streamType, data.data, !!data.keyframe);
                            } else if (data.type === 'rtp_packet') {
                                const s = mediaMonitorStreamStats[streamType] || {};
                                if (data.packets_received !== undefined) s.packetsReceived = data.packets_received;
                                if (data.packets_sent !== undefined) s.packetsSent = data.packets_sent;
                                if (data.total_bytes !== undefined) s.totalBytes = data.total_bytes;
                                if (data.packets_dropped_send !== undefined) s.packetsDropped = data.packets_dropped_send;
                                mediaMonitorStreamStats[streamType] = s;
                                mediaMonitorStats.packetsReceived = Object.values(mediaMonitorStreamStats).reduce((a, x) => a + (x.packetsReceived || 0), 0);
                                mediaMonitorStats.packetsSent = Object.values(mediaMonitorStreamStats).reduce((a, x) => a + (x.packetsSent || 0), 0);
                                mediaMonitorStats.totalBytes = Object.values(mediaMonitorStreamStats).reduce((a, x) => a + (x.totalBytes || 0), 0);
                                mediaMonitorStats.packetsDropped = Object.values(mediaMonitorStreamStats).reduce((a, x) => a + (x.packetsDropped || 0), 0);
                                updateMonitorStats();
                                if (data.rtp_payload_b64) {
                                    handleRtpPayloadForStream(streamType, data.rtp_payload_b64, data.codec, data.payload_type);
                                }
                            }
                        } catch (e) { console.error('[MediaMonitor] message parse:', e); }
                    };
                    ws.onerror = () => { updateMonitorStatus('è¿æ¥é”™è¯¯', 'error'); };
                    ws.onclose = () => {
                        if (mediaMonitorWebSockets[streamType] === ws) delete mediaMonitorWebSockets[streamType];
                    };
                } catch (e) {
                    console.error('[MediaMonitor] WebSocket create:', streamType, e);
                }
            });
        }
        
        function applyAudioMute(streamType, muted) {
            if (typeof setAudioGainForStream === 'function') setAudioGainForStream(streamType, muted ? 0 : 1);
        }
        function applyVideoMute(streamType, muted) {
            const wrap = document.getElementById('panel-body-' + streamType);
            const canvas = document.getElementById('media-monitor-canvas-' + streamType);
            if (wrap) wrap.style.opacity = muted ? '0.4' : '1';
            if (canvas) canvas.style.display = muted ? 'none' : 'block';
        }
        
        function startMediaMonitor(callId, streamType) {
            console.log('[MediaMonitor] startMediaMonitor è°ƒç”¨:', callId, streamType, 
                'å½“å‰ç›®æ ‡:', currentMonitorCallId, currentMonitorStreamType,
                'æœ‰è¿æ¥:', !!mediaMonitorWebSocket);
            
            // å¦‚æœç›®æ ‡ç›¸åŒä¸”è¿æ¥æ­£å¸¸ï¼Œç›´æ¥è¿”å›
            if (currentMonitorCallId === callId && currentMonitorStreamType === streamType && mediaMonitorWebSocket) {
                const state = mediaMonitorWebSocket.readyState;
                if (state === WebSocket.OPEN) {
                    console.log('[MediaMonitor] ç›®æ ‡ç›¸åŒä¸”è¿æ¥æ­£å¸¸ï¼Œè·³è¿‡');
                    return;
                }
            }
            
            // å½»åº•é‡ç½®ç›‘å¬çŠ¶æ€ï¼šæ¸…ç†æ’­æ”¾å™¨ã€ç»Ÿè®¡ã€çŠ¶æ€ï¼Œé¿å…åˆ‡æ¢åæœªè¿æ¥
            console.log('[MediaMonitor] å½»åº•é‡ç½®æ‰€æœ‰çŠ¶æ€ï¼Œå‡†å¤‡åˆ‡æ¢');
            cleanupMediaPlayer();
            mediaMonitorStats.packetsReceived = 0;
            mediaMonitorStats.packetsSent = 0;
            mediaMonitorStats.totalBytes = 0;
            mediaMonitorStats.lastPacketSize = 0;
            mediaMonitorStats.packetsDropped = 0;
            updateMonitorStats();
            updateMonitorStatus('è¿æ¥ä¸­...', '');
            const infoEl = document.getElementById('media-monitor-player-info');
            if (infoEl) infoEl.textContent = '';
            
            // æ¸…é™¤ä¹‹å‰çš„å»¶è¿Ÿè¿æ¥
            if (connectionTimeoutId) {
                clearTimeout(connectionTimeoutId);
                connectionTimeoutId = null;
            }
            
            // å®Œå…¨å…³é—­å¹¶æ¸…ç†æ—§è¿æ¥
            if (mediaMonitorWebSocket) {
                console.log('[MediaMonitor] å…³é—­æ—§è¿æ¥ï¼ŒçŠ¶æ€:', mediaMonitorWebSocket.readyState);
                try {
                    // ç§»é™¤æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨
                    mediaMonitorWebSocket.onopen = null;
                    mediaMonitorWebSocket.onmessage = null;
                    mediaMonitorWebSocket.onerror = null;
                    mediaMonitorWebSocket.onclose = null;
                    
                    // å…³é—­è¿æ¥
                    const state = mediaMonitorWebSocket.readyState;
                    if (state === WebSocket.OPEN || state === WebSocket.CONNECTING) {
                        mediaMonitorWebSocket.close(1000, 'Switching stream');
                    }
                } catch (e) {
                    console.warn('[MediaMonitor] å…³é—­WebSocketæ—¶å‡ºé”™:', e);
                }
                mediaMonitorWebSocket = null;
            }
            
            // é‡ç½®æ‰€æœ‰çŠ¶æ€å˜é‡
            currentMonitorCallId = callId;
            currentMonitorStreamType = streamType;
            
            // ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œç¡®ä¿æ—§è¿æ¥å®Œå…¨å…³é—­ã€æœåŠ¡ç«¯å·²æ‰§è¡Œ finally æ¸…ç†
            connectionTimeoutId = setTimeout(() => {
                connectionTimeoutId = null;
                
                // éªŒè¯ç›®æ ‡æ˜¯å¦ä»ç„¶åŒ¹é…ï¼ˆå¯èƒ½åœ¨å»¶è¿ŸæœŸé—´ç”¨æˆ·åˆ‡æ¢äº†ï¼‰
                if (currentMonitorCallId !== callId || currentMonitorStreamType !== streamType) {
                    console.warn('[MediaMonitor] ç›‘æ§ç›®æ ‡å·²å˜åŒ–ï¼Œå–æ¶ˆè¿æ¥åˆ›å»º');
                    return;
                }
                
                // å†æ¬¡æ£€æŸ¥å¹¶æ¸…ç†ï¼Œç¡®ä¿æ²¡æœ‰å…¶ä»–è¿æ¥
                if (mediaMonitorWebSocket) {
                    const state = mediaMonitorWebSocket.readyState;
                    console.warn('[MediaMonitor] æ£€æµ‹åˆ°æ®‹ç•™è¿æ¥ï¼ŒçŠ¶æ€:', state, 'æ¸…ç†ä¸­...');
                    // åªå…³é—­ä¸åŒ¹é…å½“å‰ç›®æ ‡çš„è¿æ¥
                    if (state === WebSocket.OPEN || state === WebSocket.CONNECTING) {
                        try {
                            mediaMonitorWebSocket.onopen = null;
                            mediaMonitorWebSocket.onmessage = null;
                            mediaMonitorWebSocket.onerror = null;
                            mediaMonitorWebSocket.onclose = null;
                            mediaMonitorWebSocket.close(1000, 'Switching stream');
                        } catch (e) {
                            console.warn('[MediaMonitor] å…³é—­æ®‹ç•™è¿æ¥æ—¶å‡ºé”™:', e);
                        }
                        mediaMonitorWebSocket = null;
                    } else {
                        mediaMonitorWebSocket = null;
                    }
                    // å†ç­‰å¾…ä¸€ä¸‹ï¼Œç¡®ä¿è¿æ¥å®Œå…¨å…³é—­
                    setTimeout(() => {
                        // å†æ¬¡éªŒè¯ç›®æ ‡
                        if (currentMonitorCallId === callId && currentMonitorStreamType === streamType && !mediaMonitorWebSocket) {
                            startMediaMonitorInternal(callId, streamType);
                        } else {
                            console.warn('[MediaMonitor] å»¶è¿ŸæœŸé—´ç›®æ ‡å·²å˜åŒ–æˆ–ä»æœ‰è¿æ¥ï¼Œå–æ¶ˆè¿æ¥åˆ›å»º');
                        }
                    }, 150);
                } else {
                    startMediaMonitorInternal(callId, streamType);
                }
            }, 350);
        }
        
        function startMediaMonitorInternal(callId, streamType) {
            
            // æ›´æ–°çª—å£æ ‡é¢˜
            const streamTypeNames = {
                'audio-a': 'ä¸»å«éŸ³é¢‘',
                'audio-b': 'è¢«å«éŸ³é¢‘',
                'video-a': 'ä¸»å«è§†é¢‘',
                'video-b': 'è¢«å«è§†é¢‘'
            };
            document.getElementById('media-monitor-title').textContent = 
                `åª’ä½“æµç›‘å¬: ${callId.substring(0, 20)}... / ${streamTypeNames[streamType] || streamType}`;
            
            // æ˜¾ç¤ºçª—å£
            document.getElementById('media-monitor-window').classList.add('active');
            
            // é‡ç½®ç»Ÿè®¡
            mediaMonitorStats.packetsReceived = 0;
            mediaMonitorStats.packetsSent = 0;
            mediaMonitorStats.totalBytes = 0;
            mediaMonitorStats.lastPacketSize = 0;
            mediaMonitorStats.packetsDropped = 0;
            updateMonitorStats();
            
            // è¿æ¥WebSocketï¼ˆä½¿ç”¨hostnameè€Œä¸æ˜¯hostï¼Œé¿å…0.0.0.0é—®é¢˜ï¼‰
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsHostname = window.location.hostname === '0.0.0.0' ? 'localhost' : window.location.hostname;
            // è·å–å½“å‰ HTTP ç«¯å£ï¼Œå¦‚æœä¸ºç©ºæˆ–æ— æ•ˆåˆ™ä½¿ç”¨é»˜è®¤å€¼
            const httpPort = window.location.port ? parseInt(window.location.port) : 
                             (window.location.protocol === 'https:' ? 443 : 80);
            
            // å¦‚æœé€šè¿‡ Cloudflare éš§é“è®¿é—®ï¼ˆtrycloudflare.comï¼‰ï¼ŒWebSocket ä½¿ç”¨ç›¸åŒç«¯å£ï¼ˆHTTP å‡çº§ï¼‰
            // å¦åˆ™ä½¿ç”¨ç«¯å£ + 1ï¼ˆç‹¬ç«‹ WebSocket æœåŠ¡å™¨ï¼‰
            const isCloudflareTunnel = window.location.hostname.includes('trycloudflare.com');
            const wsPort = isCloudflareTunnel ? httpPort : ((httpPort === 80 || httpPort === 443) ? 8889 : (httpPort + 1));
            
            const wsUrl = `${wsProtocol}//${wsHostname}:${wsPort}/ws/media-stream?call_id=${encodeURIComponent(callId)}&stream_type=${encodeURIComponent(streamType)}`;
            
            console.log('[MediaMonitor] è¿æ¥WebSocket:', wsUrl, 'isCloudflareTunnel:', isCloudflareTunnel);
            
            // ç¡®ä¿æ²¡æœ‰æ®‹ç•™çš„è¿æ¥ï¼ˆå°±åƒåˆ·æ–°é¡µé¢ä¸€æ ·ï¼Œå®Œå…¨æ¸…ç†ï¼‰
            if (mediaMonitorWebSocket) {
                console.warn('[MediaMonitor] æ£€æµ‹åˆ°æ®‹ç•™è¿æ¥ï¼Œå¼ºåˆ¶æ¸…ç†');
                try {
                    mediaMonitorWebSocket.onopen = null;
                    mediaMonitorWebSocket.onmessage = null;
                    mediaMonitorWebSocket.onerror = null;
                    mediaMonitorWebSocket.onclose = null;
                    if (mediaMonitorWebSocket.readyState !== WebSocket.CLOSED && 
                        mediaMonitorWebSocket.readyState !== WebSocket.CLOSING) {
                        mediaMonitorWebSocket.close();
                    }
                } catch (e) {
                    console.warn('[MediaMonitor] æ¸…ç†æ®‹ç•™è¿æ¥æ—¶å‡ºé”™:', e);
                }
                mediaMonitorWebSocket = null;
            }
            
            // ç›´æ¥åˆ›å»ºè¿æ¥ï¼ˆå°±åƒåˆ·æ–°é¡µé¢ä¸€æ ·ï¼Œç®€å•ç›´æ¥ï¼‰
            try {
                console.log('[MediaMonitor] åˆ›å»ºæ–°çš„WebSocketè¿æ¥:', callId, streamType, 'URL:', wsUrl);
                mediaMonitorWebSocket = new WebSocket(wsUrl);
                
                mediaMonitorWebSocket.onopen = () => {
                    console.log('[MediaMonitor] WebSocketè¿æ¥å·²å»ºç«‹:', callId, streamType, 
                        'å½“å‰ç›‘æ§:', currentMonitorCallId, currentMonitorStreamType,
                        'è¿æ¥çŠ¶æ€:', mediaMonitorWebSocket.readyState);
                    // éªŒè¯è¿™æ˜¯å½“å‰æ´»åŠ¨çš„è¿æ¥
                    if (currentMonitorCallId === callId && currentMonitorStreamType === streamType) {
                        updateMonitorStatus('å·²è¿æ¥', 'connected');
                        console.log('[MediaMonitor] è¿æ¥éªŒè¯é€šè¿‡ï¼Œä¿æŒè¿æ¥');
                    } else {
                        console.warn('[MediaMonitor] è¿æ¥å»ºç«‹ä½†callId/streamTypeä¸åŒ¹é…ï¼Œå…³é—­è¿æ¥');
                        console.warn('[MediaMonitor] æœŸæœ›:', callId, streamType, 'å®é™…:', currentMonitorCallId, currentMonitorStreamType);
                        try {
                            mediaMonitorWebSocket.close(1000, 'Connection mismatch');
                        } catch (e) {
                            console.warn('[MediaMonitor] å…³é—­ä¸åŒ¹é…è¿æ¥æ—¶å‡ºé”™:', e);
                        }
                        mediaMonitorWebSocket = null;
                    }
                };
                
                mediaMonitorWebSocket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('[MediaMonitor] æ”¶åˆ°æ¶ˆæ¯:', callId, streamType, data.type);
                        if (data.type === 'connected') {
                            console.log('[MediaMonitor] è¿æ¥æˆåŠŸ:', callId, streamType, data.message);
                            updateMonitorStatus('ç›‘å¬ä¸­...', 'connected');
                            // åˆå§‹åŒ–æ’­æ”¾å™¨ï¼ˆå¦‚æœè¿˜æ²¡æœ‰åˆå§‹åŒ–æˆ–å·²å…³é—­ï¼‰
                            if (!audioContext || audioContext.state === 'closed') {
                                initMediaPlayer(streamType);
                            } else if (streamType.startsWith('audio') && !isPlayingAudio) {
                                // å¦‚æœæ’­æ”¾å™¨å·²å­˜åœ¨ä½†æœªå¯åŠ¨ï¼Œé‡æ–°å¯åŠ¨
                                initMediaPlayer(streamType);
                            }
                        } else if (data.type === 'mse_init') {
                            if (currentMonitorStreamType && currentMonitorStreamType.startsWith('video') && data.data) initMSEForStreamWithBackendInit(currentMonitorStreamType, data.data, data.codec);
                        } else if (data.type === 'mse_fragment') {
                            if (currentMonitorStreamType && currentMonitorStreamType.startsWith('video') && data.data) appendMSEFragmentBytes(currentMonitorStreamType, data.data, !!data.keyframe);
                        } else if (data.type === 'rtp_packet') {
                            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                            if (data.packets_received !== undefined) {
                                mediaMonitorStats.packetsReceived = data.packets_received;
                            }
                            if (data.packets_sent !== undefined) {
                                mediaMonitorStats.packetsSent = data.packets_sent;
                            }
                            if (data.total_bytes !== undefined) {
                                mediaMonitorStats.totalBytes = data.total_bytes;
                            }
                            if (data.packet_size !== undefined) {
                                mediaMonitorStats.lastPacketSize = data.packet_size;
                            }
                            if (data.packets_dropped_send !== undefined) {
                                mediaMonitorStats.packetsDropped = data.packets_dropped_send;
                            }
                            updateMonitorStats();
                            
                            // å¤„ç†RTP payloadç”¨äºæ’­æ”¾
                            if (data.rtp_payload_b64) {
                                handleRtpPayload(data.rtp_payload_b64, currentMonitorStreamType, data.codec, data.payload_type);
                            }
                        } else if (data.type === 'heartbeat') {
                            // å¿ƒè·³ï¼Œä¿æŒè¿æ¥
                        } else if (data.type === 'error') {
                            updateMonitorStatus('é”™è¯¯: ' + data.message, 'error');
                            const infoEl = document.getElementById('media-monitor-player-info');
                            if (infoEl) {
                                infoEl.textContent = 'é”™è¯¯: ' + data.message;
                            }
                            // æ˜¾ç¤ºé”™è¯¯åï¼Œå»¶è¿Ÿå…³é—­è¿æ¥
                            setTimeout(() => {
                                if (mediaMonitorWebSocket) {
                                    mediaMonitorWebSocket.close();
                                }
                            }, 3000);
                        }
                    } catch (e) {
                        console.error('[MediaMonitor] è§£ææ¶ˆæ¯å¤±è´¥:', e);
                    }
                };
                
                mediaMonitorWebSocket.onerror = (error) => {
                    console.error('[MediaMonitor] WebSocketé”™è¯¯:', callId, streamType, error, 'è¿æ¥çŠ¶æ€:', mediaMonitorWebSocket?.readyState);
                    updateMonitorStatus('è¿æ¥é”™è¯¯', 'error');
                };
                
                const currentWs = mediaMonitorWebSocket; // ä¿å­˜å½“å‰WebSocketå¼•ç”¨
                mediaMonitorWebSocket.onclose = (event) => {
                    console.log('[MediaMonitor] WebSocketè¿æ¥å·²å…³é—­:', callId, streamType, 
                        'code:', event.code, 'reason:', event.reason, 'wasClean:', event.wasClean,
                        'å½“å‰ç›®æ ‡:', currentMonitorCallId, currentMonitorStreamType,
                        'æ˜¯å½“å‰è¿æ¥:', mediaMonitorWebSocket === currentWs);
                    // åªæœ‰åœ¨å½“å‰è¿æ¥å…³é—­æ—¶æ‰æ›´æ–°çŠ¶æ€
                    if (mediaMonitorWebSocket === currentWs) {
                        // å¦‚æœæ˜¯æ­£å¸¸å…³é—­ï¼ˆç”¨æˆ·ä¸»åŠ¨å…³é—­ï¼‰ï¼Œä¸æ›´æ–°çŠ¶æ€
                        // å¦‚æœæ˜¯å¼‚å¸¸å…³é—­ï¼Œæ˜¾ç¤º"å·²æ–­å¼€"
                        if (event.code !== 1000 && event.code !== 1001 && !event.wasClean) {
                            updateMonitorStatus('å·²æ–­å¼€', 'error');
                        } else if (currentMonitorCallId === callId && currentMonitorStreamType === streamType) {
                            // å¦‚æœè¿™æ˜¯å½“å‰æ´»åŠ¨çš„è¿æ¥ï¼Œæ›´æ–°çŠ¶æ€
                            updateMonitorStatus('æœªè¿æ¥', '');
                        }
                        mediaMonitorWebSocket = null;
                    }
                };
            } catch (e) {
                console.error('[MediaMonitor] åˆ›å»ºWebSocketå¤±è´¥:', callId, streamType, e);
                updateMonitorStatus('è¿æ¥å¤±è´¥: ' + e.message, 'error');
                mediaMonitorWebSocket = null;
            }
        }
        
        function stopMediaMonitor() {
            if (mediaMonitorWebSocket) {
                mediaMonitorWebSocket.close();
                mediaMonitorWebSocket = null;
            }
            // ä¸æ¸…ç†æ’­æ”¾å™¨ï¼Œå› ä¸ºå¯èƒ½é©¬ä¸Šè¦åˆ‡æ¢åˆ°å¦ä¸€ä¸ªæµ
            // cleanupMediaPlayer(); // æ³¨é‡Šæ‰ï¼Œè®©æ’­æ”¾å™¨ä¿æŒçŠ¶æ€
            currentMonitorCallId = null;
            currentMonitorStreamType = null;
            updateMonitorStatus('æœªè¿æ¥', '');
        }
        
        function updateMonitorStats() {
            document.getElementById('stat-packets-received').textContent = mediaMonitorStats.packetsReceived.toLocaleString();
            document.getElementById('stat-packets-sent').textContent = mediaMonitorStats.packetsSent.toLocaleString();
            document.getElementById('stat-total-bytes').textContent = formatBytes(mediaMonitorStats.totalBytes);
            const packetSizeEl = document.getElementById('stat-packet-size');
            if (packetSizeEl) packetSizeEl.textContent = formatBytes(mediaMonitorStats.lastPacketSize);
            const droppedEl = document.getElementById('stat-packets-dropped');
            if (droppedEl) droppedEl.textContent = (mediaMonitorStats.packetsDropped || 0).toLocaleString();
        }
        
        function updateMonitorStatus(text, className) {
            const statusEl = document.getElementById('media-monitor-status');
            statusEl.textContent = text;
            statusEl.className = 'media-monitor-status ' + className;
        }
        
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
        
        // éŸ³è§†é¢‘æ’­æ”¾å™¨
        let mediaPlayerAudio = null;
        let mediaPlayerVideo = null;
        let audioContext = null;
        let audioBufferQueue = [];
        let audioScriptProcessor = null;
        let audioPlaybackTime = 0;
        let videoChunks = [];
        let mediaSource = null;
        let sourceBuffer = null;
        let isPlayingAudio = false;
        // H.264 è§£ç ä¸æ˜¾ç¤ºï¼ˆWebCodecsï¼‰
        let h264SPS = null;
        let h264PPS = null;
        let h264FUABuffer = null;  // { nalHeader: number, chunks: Uint8Array[] }
        let videoDecoder = null;
        let videoCanvas = null;
        let videoCtx = null;
        let videoFrameCount = 0;
        let videoDecodeQueue = [];
        // å››è·¯åª’ä½“ï¼šä¸»å«/è¢«å« éŸ³é¢‘/è§†é¢‘
        let audioBufferQueues = { 'audio-a': [], 'audio-b': [] };
        let audioGainNodes = {};
        let audioScriptProcessorsMulti = {};
        let videoDecodersByStream = {};  // streamType -> VideoDecoder
        let h264SPSByStream = {};
        let h264PPSByStream = {};
        let lastVideoTimeByStream = {};
        let videoFrameCountByStream = {};
        let videoStreamDebug = {};  // streamType -> { lastError, lastNal, framesSentToDecoder }
        
        function setVideoStreamStatus(streamType, msg, isError) {
            const infoEl = document.getElementById('info-' + streamType);
            if (!infoEl) return;
            if (!videoStreamDebug[streamType]) videoStreamDebug[streamType] = {};
            if (isError) {
                // åªå­˜ç®€çŸ­é”™è¯¯ï¼Œé¿å…ä¸ getVideoStreamStatusLine é€’å½’æ‹¼æ¥å¯¼è‡´çŠ¶æ€æ çˆ†é•¿
                const shortMsg = (msg.indexOf(' | ') >= 0) ? msg.split(' | ')[0] : msg;
                videoStreamDebug[streamType].lastError = shortMsg.length > 120 ? shortMsg.slice(0, 120) + 'â€¦' : shortMsg;
            }
            infoEl.textContent = msg;
            infoEl.style.color = isError ? '#f48771' : '#858585';
        }
        
        function getVideoStreamStatusLine(streamType) {
            const d = videoStreamDebug[streamType] || {};
            const sps = !!h264SPSByStream[streamType];
            const pps = !!h264PPSByStream[streamType];
            const dec = videoDecodersByStream[streamType];
            const decState = dec ? dec.state : 'æœªåˆ›å»º';
            const frames = videoFrameCountByStream[streamType] || 0;
            const sent = d.framesSentToDecoder || 0;
            const errRaw = d.lastError ? ' é”™è¯¯: ' + d.lastError : '';
            const err = errRaw.length > 100 ? errRaw.slice(0, 100) + 'â€¦' : errRaw;
            return `SPS:${sps ? 'âœ“' : 'âœ—'} PPS:${pps ? 'âœ“' : 'âœ—'} è§£ç å™¨:${decState} å·²é€å¸§:${sent} å·²è§£ç :${frames}${err}`;
        }
        
        function setAudioGainForStream(streamType, value) {
            const g = audioGainNodes[streamType];
            if (g) g.gain.value = value;
        }
        
        function initMediaPlayerMultiStream(streams) {
            const hasAudio = streams.indexOf('audio-a') >= 0 || streams.indexOf('audio-b') >= 0;
            const hasVideo = streams.indexOf('video-a') >= 0 || streams.indexOf('video-b') >= 0;
            if (hasAudio) {
                try {
                    if (!audioContext || audioContext.state === 'closed') {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    if (audioContext.state === 'suspended') audioContext.resume().catch(() => {});
                    audioBufferQueues['audio-a'] = [];
                    audioBufferQueues['audio-b'] = [];
                    const dest = audioContext.destination;
                    function concatFloat32(a, b) {
                        const c = new Float32Array(a.length + b.length);
                        c.set(a); c.set(b, a.length);
                        return c;
                    }
                    ['audio-a', 'audio-b'].forEach(st => {
                        if (audioScriptProcessorsMulti[st]) {
                            try { audioScriptProcessorsMulti[st].disconnect(); } catch (e) {}
                        }
                        const gain = audioContext.createGain();
                        gain.gain.value = mediaMonitorMute[st] ? 0 : 1;
                        gain.connect(dest);
                        audioGainNodes[st] = gain;
                        const proc = audioContext.createScriptProcessor(4096, 0, 1);
                        const q = audioBufferQueues[st];
                        let buf = new Float32Array(0);
                        proc.onaudioprocess = function(e) {
                            const out = e.outputBuffer.getChannelData(0);
                            const len = out.length;
                            while (buf.length < len && q.length > 0) buf = concatFloat32(buf, q.shift());
                            if (buf.length >= len) {
                                out.set(buf.subarray(0, len));
                                buf = buf.subarray(len);
                            } else {
                                out.fill(0);
                                if (buf.length > 0) { out.set(buf); buf = new Float32Array(0); }
                            }
                        };
                        proc.connect(gain);
                        audioScriptProcessorsMulti[st] = proc;
                    });
                } catch (e) { console.error('[MediaMonitor] initMediaPlayerMultiStream audio:', e); }
            }
            if (hasVideo) {
                const videoUnsupported = typeof window.VideoDecoder === 'undefined';
                ['video-a', 'video-b'].forEach(st => {
                    h264SPSByStream[st] = null;
                    h264PPSByStream[st] = null;
                    lastVideoTimeByStream[st] = 0;
                    videoFrameCountByStream[st] = 0;
                    videoStreamDebug[st] = {};
                    if (videoDecodersByStream[st]) {
                        try { videoDecodersByStream[st].close(); } catch (e) {}
                        videoDecodersByStream[st] = null;
                    }
                    setVideoStreamStatus(st, videoUnsupported
                        ? 'å°†ä½¿ç”¨ MSE å›é€€æ’­æ”¾ï¼ˆå…¼å®¹ Firefox ç­‰ï¼‰'
                        : 'ç­‰å¾… RTP (SPS/PPS/å…³é”®å¸§)â€¦', false);
                });
            }
        }
        
        function initMediaPlayer(streamType) {
            const playerDiv = document.getElementById('media-monitor-player');
            const audioEl = document.getElementById('media-monitor-audio');
            const videoEl = document.getElementById('media-monitor-video');
            const infoEl = document.getElementById('media-monitor-player-info');
            
            playerDiv.style.display = 'block';
            
            if (streamType.startsWith('audio')) {
                // éŸ³é¢‘æ’­æ”¾ï¼šä½¿ç”¨Web Audio API
                audioEl.style.display = 'block';
                videoEl.style.display = 'none';
                infoEl.textContent = 'éŸ³é¢‘æµï¼šæ­£åœ¨æ¥æ”¶RTPåŒ…ï¼Œè§£ç ä¸­...';
                
                try {
                    // å¦‚æœaudioContextå·²å…³é—­æˆ–ä¸å­˜åœ¨ï¼Œé‡æ–°åˆ›å»º
                    if (!audioContext || audioContext.state === 'closed') {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    // å¦‚æœaudioContextè¢«æš‚åœï¼Œæ¢å¤å®ƒ
                    if (audioContext.state === 'suspended') {
                        audioContext.resume().catch(e => {
                            console.error('[MediaMonitor] æ¢å¤AudioContextå¤±è´¥:', e);
                        });
                    }
                    
                    mediaPlayerAudio = audioEl;
                    // å¦‚æœé˜Ÿåˆ—å·²å­˜åœ¨ï¼Œæ¸…ç©ºå®ƒï¼ˆåˆ‡æ¢æµæ—¶ï¼‰
                    if (!audioBufferQueue) {
                        audioBufferQueue = [];
                    } else {
                        audioBufferQueue.length = 0; // æ¸…ç©ºé˜Ÿåˆ—
                    }
                    audioPlaybackTime = 0;
                    
                    // å¦‚æœScriptProcessorNodeå·²å­˜åœ¨ï¼Œå…ˆæ–­å¼€
                    if (audioScriptProcessor) {
                        try {
                            audioScriptProcessor.disconnect();
                        } catch (e) {}
                    }
                    
                    // ä½¿ç”¨ScriptProcessorNodeè¿›è¡Œè¿ç»­æ’­æ”¾
                    // æ³¨æ„ï¼šScriptProcessorNodeå·²åºŸå¼ƒï¼Œä½†å¯¹äºç®€å•åœºæ™¯ä»ç„¶å¯ç”¨
                    const bufferSize = 4096;
                    audioScriptProcessor = audioContext.createScriptProcessor(bufferSize, 0, 1);
                    
                    // ä½¿ç”¨ä¸€ä¸ªè¿ç»­çš„Float32Arrayç¼“å†²åŒºæ¥ç´¯ç§¯éŸ³é¢‘æ•°æ®
                    let audioBuffer = new Float32Array(0);
                    
                    audioScriptProcessor.onaudioprocess = function(e) {
                        const output = e.outputBuffer.getChannelData(0);
                        const outputLength = output.length;
                        
                        // å¦‚æœç¼“å†²åŒºæ•°æ®ä¸è¶³ï¼Œå°è¯•ä»é˜Ÿåˆ—è·å–æ›´å¤šæ•°æ®
                        while (audioBuffer.length < outputLength && audioBufferQueue.length > 0) {
                            const newSamples = audioBufferQueue.shift();
                            const combined = new Float32Array(audioBuffer.length + newSamples.length);
                            combined.set(audioBuffer);
                            combined.set(newSamples, audioBuffer.length);
                            audioBuffer = combined;
                        }
                        
                        // å¡«å……è¾“å‡ºç¼“å†²åŒº
                        if (audioBuffer.length >= outputLength) {
                            // æœ‰è¶³å¤Ÿçš„æ•°æ®ï¼Œå¤åˆ¶åˆ°è¾“å‡º
                            output.set(audioBuffer.subarray(0, outputLength));
                            // ä¿ç•™å‰©ä½™æ•°æ®
                            audioBuffer = audioBuffer.subarray(outputLength);
                        } else {
                            // æ•°æ®ä¸è¶³ï¼Œå¡«å……é™éŸ³
                            output.fill(0);
                            // å¦‚æœæœ‰ä¸€äº›æ•°æ®ï¼Œå…ˆå¡«å……å®ƒä»¬
                            if (audioBuffer.length > 0) {
                                output.set(audioBuffer);
                                audioBuffer = new Float32Array(0);
                            }
                        }
                    };
                    
                    audioScriptProcessor.connect(audioContext.destination);
                    isPlayingAudio = true;
                } catch (e) {
                    console.error('[MediaMonitor] åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡å¤±è´¥:', e);
                    infoEl.textContent = 'éŸ³é¢‘æ’­æ”¾å™¨åˆå§‹åŒ–å¤±è´¥: ' + e.message;
                }
            } else if (streamType.startsWith('video')) {
                audioEl.style.display = 'none';
                videoEl.style.display = 'none';
                const canvasEl = document.getElementById('media-monitor-video-canvas');
                if (canvasEl) {
                    canvasEl.style.display = 'block';
                    canvasEl.width = 640;
                    canvasEl.height = 480;
                    videoCanvas = canvasEl;
                    videoCtx = canvasEl.getContext('2d');
                }
                videoFrameCount = 0;
                h264SPS = null;
                h264PPS = null;
                h264FUABuffer = null;
                if (videoDecoder) {
                    try { videoDecoder.close(); } catch (e) {}
                    videoDecoder = null;
                }
                if (typeof VideoDecoder === 'undefined') {
                    infoEl.textContent = 'è§†é¢‘æµï¼šå½“å‰æµè§ˆå™¨ä¸æ”¯æŒ WebCodecsï¼Œæ— æ³•è§£ç  H.264 ç”»é¢ï¼ˆè¯·ä½¿ç”¨ Chrome/Edgeï¼‰';
                } else {
                    infoEl.textContent = 'è§†é¢‘æµï¼šç­‰å¾… SPS/PPS ä¸å…³é”®å¸§â€¦';
                }
            }
        }
        
        function cleanupMediaPlayer() {
            if (audioScriptProcessor) {
                try { audioScriptProcessor.disconnect(); } catch (e) {}
                audioScriptProcessor = null;
            }
            ['audio-a','audio-b'].forEach(st => {
                if (audioScriptProcessorsMulti[st]) {
                    try { audioScriptProcessorsMulti[st].disconnect(); } catch (e) {}
                    audioScriptProcessorsMulti[st] = null;
                }
                if (audioBufferQueues[st]) audioBufferQueues[st].length = 0;
            });
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close().catch(() => {});
            }
            audioContext = null;
            audioBufferQueue = [];
            isPlayingAudio = false;
            
            if (mediaSource && mediaSource.readyState === 'open') {
                try { mediaSource.endOfStream(); } catch (e) {}
            }
            mediaSource = null;
            sourceBuffer = null;
            videoChunks = [];
            h264SPS = null;
            h264PPS = null;
            h264FUABuffer = null;
            if (videoDecoder) {
                try { videoDecoder.close(); } catch (e) {}
                videoDecoder = null;
            }
            ['video-a','video-b'].forEach(st => {
                if (videoDecodersByStream[st]) {
                    try { videoDecodersByStream[st].close(); } catch (e) {}
                    videoDecodersByStream[st] = null;
                    videoDecoderHasReceivedKeyframeByStream[st] = false;
                }
                var mseVideo = mseVideoElByStream[st];
                var ms = mseMediaSourceByStream[st];
                mseMediaSourceByStream[st] = null;
                mseSourceBufferByStream[st] = null;
                mseVideoElByStream[st] = null;
                mseAppendQueueByStream[st] = [];
                mseInvalidErrorShownAtByStream[st] = 0;
                h264SPSByStream[st] = null;
                h264PPSByStream[st] = null;
                if (mseVideo && mseVideo.src) {
                    try { URL.revokeObjectURL(mseVideo.src); } catch (e) {}
                    mseVideo.removeAttribute('src');
                    mseVideo.style.display = 'none';
                }
                if (ms && ms.readyState === 'open') {
                    try { ms.endOfStream(); } catch (e) {}
                }
            });
            if (window.h264FUABufferByStream) window.h264FUABufferByStream = {};
            const canvasEl = document.getElementById('media-monitor-video-canvas');
            if (canvasEl) canvasEl.style.display = 'none';
            videoCanvas = null;
            videoCtx = null;
        }
        
        // G.711è§£ç è¡¨ï¼ˆÎ¼-lawå’ŒA-lawï¼‰- ä½¿ç”¨æ ‡å‡†çš„ITU-T G.711è§£ç ç®—æ³•
        const G711_ULAW_TABLE = new Int16Array(256);
        const G711_ALAW_TABLE = new Int16Array(256);
        
        // åˆå§‹åŒ–Î¼-lawè§£ç è¡¨ï¼ˆITU-T G.711æ ‡å‡†ï¼‰
        // Î¼-lawè§£ç ï¼šåè½¬æ‰€æœ‰ä½ï¼Œæå–ç¬¦å·ã€æŒ‡æ•°å’Œå°¾æ•°
        for (let i = 0; i < 256; i++) {
            const reversed = (~i) & 0xFF;
            const sign = (reversed & 0x80) ? -1 : 1;
            const exponent = (reversed >> 4) & 0x07;
            const mantissa = (reversed & 0x0F) | 0x10;
            
            // æ ‡å‡†Î¼-lawè§£ç å…¬å¼
            let value = ((mantissa << (exponent + 3)) - 0x84) << 2;
            G711_ULAW_TABLE[i] = sign * value;
        }
        
        // åˆå§‹åŒ–A-lawè§£ç è¡¨ï¼ˆITU-T G.711æ ‡å‡†ï¼‰
        // A-lawè§£ç ï¼šåè½¬å¶æ•°ä½ï¼ˆ0,2,4,6ä½ï¼‰
        for (let i = 0; i < 256; i++) {
            const reversed = i ^ 0x55;
            const sign = (reversed & 0x80) ? -1 : 1;
            const exponent = (reversed >> 4) & 0x07;
            const mantissa = reversed & 0x0F;
            
            let value;
            if (exponent === 0) {
                value = (mantissa << 4) + 8;
            } else {
                value = ((mantissa << 4) + 0x108) << (exponent - 1);
            }
            G711_ALAW_TABLE[i] = sign * value;
        }
        
        // éŸ³é¢‘é‡é‡‡æ ·ï¼šä»8kHzåˆ°44.1kHz
        function resampleAudio8kTo44k(inputData, inputSampleRate, outputSampleRate) {
            const ratio = outputSampleRate / inputSampleRate;
            const outputLength = Math.floor(inputData.length * ratio);
            const outputData = new Float32Array(outputLength);
            
            for (let i = 0; i < outputLength; i++) {
                const srcIndex = i / ratio;
                const srcIndexFloor = Math.floor(srcIndex);
                const srcIndexCeil = Math.min(srcIndexFloor + 1, inputData.length - 1);
                const t = srcIndex - srcIndexFloor;
                
                // çº¿æ€§æ’å€¼
                outputData[i] = inputData[srcIndexFloor] * (1 - t) + inputData[srcIndexCeil] * t;
            }
            
            return outputData;
        }
        
        // G.711è§£ç 
        function decodeG711(payload, codec) {
            const samples = new Int16Array(payload.length);
            const table = (codec === 'PCMU' || codec === '0') ? G711_ULAW_TABLE : G711_ALAW_TABLE;
            
            // è§£ç æ¯ä¸ªå­—èŠ‚
            for (let i = 0; i < payload.length; i++) {
                samples[i] = table[payload[i]];
            }
            
            // è½¬æ¢ä¸ºFloat32ï¼ˆ-1.0åˆ°1.0èŒƒå›´ï¼‰ï¼Œç¡®ä¿å€¼åœ¨æœ‰æ•ˆèŒƒå›´å†…
            const floatSamples = new Float32Array(samples.length);
            for (let i = 0; i < samples.length; i++) {
                // é™åˆ¶åœ¨-32768åˆ°32767èŒƒå›´å†…ï¼Œç„¶åå½’ä¸€åŒ–åˆ°-1.0åˆ°1.0
                let sample = Math.max(-32768, Math.min(32767, samples[i]));
                floatSamples[i] = sample / 32768.0;
            }
            
            return floatSamples;
        }
        
        // ä» SPS+PPS æ„å»º AVCDecoderConfigurationRecordï¼ˆavcCï¼‰ï¼Œä¾› WebCodecs æˆ– fMP4 ä½¿ç”¨
        function buildAvcC(sps, pps) {
            if (!sps || !pps || sps.length < 4 || pps.length < 1) return new Uint8Array(0);
            const spsLen = sps.length;
            const ppsLen = pps.length;
            const buf = new ArrayBuffer(11 + spsLen + ppsLen);
            const v = new DataView(buf);
            let o = 0;
            v.setUint8(o++, 1);
            v.setUint8(o++, sps[1]);
            v.setUint8(o++, sps[2]);
            v.setUint8(o++, sps[3]);
            v.setUint8(o++, 0xFF);
            v.setUint8(o++, 0xE1);
            v.setUint16(o, spsLen, false); o += 2;
            new Uint8Array(buf).set(sps, o); o += spsLen;
            v.setUint8(o++, 1);
            v.setUint16(o, ppsLen, false); o += 2;
            new Uint8Array(buf).set(pps, o);
            return new Uint8Array(buf);
        }
        
        // ---------- MSE å›é€€ï¼šæ—  WebCodecs æ—¶ç”¨ Media Source Extensions æ’­æ”¾ H.264ï¼ˆå…¼å®¹ Firefox ç­‰ï¼‰ ----------
        let mseMediaSourceByStream = {};
        let mseSourceBufferByStream = {};
        let mseVideoElByStream = {};
        let mseAppendPendingByStream = {};
        let mseAppendQueueByStream = {};
        let msePendingNalsByStream = {};  // MSE æœªå°±ç»ªæ—¶æš‚å­˜ NALï¼Œé¿å…ä¸¢å¤±é¦–å¸§/å…³é”®å¸§
        let mseBackendPendingFragmentsByStream = {};  // åå° fMP4ï¼šSourceBuffer æœªå°±ç»ªæ—¶æš‚å­˜ fragment
        let mseSequenceByStream = {};
        let mseDtsByStream = {};
        let mseInvalidErrorShownAtByStream = {};
        let mseDidPlayByStream = {};
        let mseHasAppendedKeyframeByStream = {};  // æœª append å…³é”®å¸§å‰ä¸ append P å¸§ï¼Œé¿å…æµè§ˆå™¨æŠ¥é”™å¯¼è‡´åå¤é‡å»º MediaSource
        let videoDecoderHasReceivedKeyframeByStream = {};  // WebCodecsï¼šæœªé€å…³é”®å¸§å‰ä¸é€ P å¸§ï¼Œé¿å… "Key frame is required" / bitstream buffer æŠ¥é”™
        let mseInitLoggedByStream = {};
        let mseSourceOpenLoggedByStream = {};
        let mseSPSLoggedByStream = {};
        let msePPSLoggedByStream = {};
        
        function writeU32BE(arr, offset, val) {
            arr[offset]= (val >>> 24) & 0xff;
            arr[offset+1]=(val >>> 16) & 0xff;
            arr[offset+2]=(val >>> 8) & 0xff;
            arr[offset+3]= val & 0xff;
        }
        function writeBox(arr, offset, type, payload) {
            const len = 8 + (payload ? payload.length : 0);
            if (offset + len > arr.length) {
                throw new Error('writeBox overflow: type=' + type + ' offset=' + offset + ' len=' + len + ' arr.length=' + arr.length);
            }
            writeU32BE(arr, offset, len);
            arr[offset+4]=type.charCodeAt(0); arr[offset+5]=type.charCodeAt(1);
            arr[offset+6]=type.charCodeAt(2); arr[offset+7]=type.charCodeAt(3);
            if (payload) arr.set(payload, offset + 8);
            return offset + len;
        }
        function buildMp4InitSegment(sps, pps) {
            if (!sps || !pps || sps.length < 4 || pps.length < 1) {
                if (typeof console !== 'undefined' && console.warn) console.warn('[MSE-init] buildMp4InitSegment: æ— æ•ˆ SPS/PPS', 'sps.len=', sps && sps.length, 'pps.len=', pps && pps.length);
                return new Uint8Array(0);
            }
            if (sps.length < 7 || pps.length < 4) {
                if (typeof console !== 'undefined' && console.warn) console.warn('[MSE-init] SPS/PPS è¿‡çŸ­ï¼Œç­‰å¾…å®Œæ•´å‚æ•° sps.len=', sps.length, 'pps.len=', pps.length);
                return new Uint8Array(0);
            }
            const avcC = buildAvcC(sps, pps);
            if (!avcC || avcC.length === 0) return new Uint8Array(0);
            const codec = 'avc1.' + [sps[1],sps[2],sps[3]].map(function(x){return x.toString(16).padStart(2,'0');}).join('');
            const avcCBox = new Uint8Array(8 + avcC.length);
            writeU32BE(avcCBox, 0, 8 + avcC.length);
            avcCBox[4]=0x61; avcCBox[5]=0x76; avcCBox[6]=0x63; avcCBox[7]=0x43;
            avcCBox.set(avcC, 8);
            const avc1Payload = new Uint8Array(86 + avcCBox.length);
            avc1Payload.set(new Uint8Array([
                0,0,0,0,0,0,0,1, 0,0,0,0,0,0,0,0,
                0,0,0,0, 0x02,0x80, 0x01,0xe0, 0,0,0,0,0,0,0,0,
                0,0,0,0, 0,0,0,0, 0,0,0,0,
                0x00,0x48,0x00,0x00, 0x00,0x48,0x00,0x00, 0,0,0,0,
                0x00,0x06,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00
            ]), 0);
            avc1Payload.set(avcCBox, 86);
            const stsdPayload = new Uint8Array(8 + 8 + avc1Payload.length);
            stsdPayload[0]=0; stsdPayload[1]=0; stsdPayload[2]=0; stsdPayload[3]=0;
            writeU32BE(stsdPayload, 4, 1);
            stsdPayload.set(avc1Payload, 8);
            const stsdBoxLen = 8 + stsdPayload.length;
            var sttsPayload = new Uint8Array([0,0,0,0, 0,0,0,0, 0,0,0,0]);
            var stscPayload = new Uint8Array([0,0,0,0, 0,0,0,0, 0,0,0,0]);
            var stszPayload = new Uint8Array([0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0]);
            var stcoPayload = new Uint8Array([0,0,0,0, 0,0,0,0]);
            const stbl = new Uint8Array(8 + stsdBoxLen + (8+sttsPayload.length) + (8+stscPayload.length) + (8+stszPayload.length) + (8+stcoPayload.length));
            let off = 0;
            off = writeBox(stbl, off, 'stsd', stsdPayload);
            off = writeBox(stbl, off, 'stts', sttsPayload);
            off = writeBox(stbl, off, 'stsc', stscPayload);
            off = writeBox(stbl, off, 'stsz', stszPayload);
            off = writeBox(stbl, off, 'stco', stcoPayload);
            const drefPayload = new Uint8Array([0,0,0,0, 0,0,0,1, 0,0,0,0x0c, 0x75,0x72,0x6c,0x20, 0,0,0,1]);
            const drefBox = new Uint8Array(8 + drefPayload.length);
            writeBox(drefBox, 0, 'dref', drefPayload);
            const dinf = new Uint8Array(8 + drefBox.length);
            writeBox(dinf, 0, 'dinf', drefBox);
            const minf = new Uint8Array(20 + dinf.length + 8 + stbl.length);
            off = 0;
            off = writeBox(minf, off, 'vmhd', new Uint8Array([0,0,0,1, 0,0,0,0, 0,0,0,0]));
            minf.set(dinf, off); off += dinf.length;
            writeU32BE(minf, off, stbl.length); minf[off+4]=0x73; minf[off+5]=0x74; minf[off+6]=0x62; minf[off+7]=0x6c; off += 8;
            minf.set(stbl, off);
            const hdlrPayload = new Uint8Array([0,0,0,0, 0,0,0,0, 0x76,0x69,0x64,0x65, 0,0,0,0,0,0,0,0,0,0,0,0, 0x56,0x69,0x64,0x65,0x6f,0x48,0x61,0x6e,0x64,0x6c,0x65,0x72,0x00]);
            const mdia = new Uint8Array(8 + 32 + (8 + hdlrPayload.length) + (8 + minf.length));
            off = 0;
            const mdhd = new Uint8Array(32);
            mdhd[0]=0; mdhd[1]=0; mdhd[2]=0; mdhd[3]=0;
            writeU32BE(mdhd,4, 0); writeU32BE(mdhd,8, 0); writeU32BE(mdhd,12, 90000); writeU32BE(mdhd,16, 0);
            mdhd[20]=0x55; mdhd[21]=0xc4; writeU32BE(mdhd,22, 0);
            off = writeBox(mdia, off, 'mdhd', mdhd);
            off = writeBox(mdia, off, 'hdlr', hdlrPayload);
            off = writeBox(mdia, off, 'minf', minf);
            const trak = new Uint8Array(8 + 92 + 8 + mdia.length);
            off = 0;
            const tkhd = new Uint8Array(92);
            tkhd[0]=0; tkhd[4]=0; tkhd[5]=0; tkhd[6]=0x03;
            writeU32BE(tkhd,12, 1); writeU32BE(tkhd,20, 0); writeU32BE(tkhd,28, 1);
            writeU32BE(tkhd,36, 0); writeU32BE(tkhd,40, 0); writeU32BE(tkhd,44, 0);
            writeU32BE(tkhd,48, 0x00010000); writeU32BE(tkhd,52, 0); writeU32BE(tkhd,56, 0);
            writeU32BE(tkhd,60, 0); writeU32BE(tkhd,64, 0x00010000); writeU32BE(tkhd,68, 0);
            writeU32BE(tkhd,72, 0x0140); writeU32BE(tkhd,76, 0x00e0); writeU32BE(tkhd,80, 0);
            off = writeBox(trak, off, 'tkhd', tkhd);
            off = writeBox(trak, off, 'mdia', mdia);
            const mvex = new Uint8Array(8 + 8 + 32);
            writeBox(mvex, 0, 'trex', new Uint8Array([0,0,0,0, 0,0,0,1, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0]));
            const mvhd = new Uint8Array(108);
            mvhd[0]=0; writeU32BE(mvhd,4, 0); writeU32BE(mvhd,8, 0); writeU32BE(mvhd,12, 90000);
            writeU32BE(mvhd,16, 0); writeU32BE(mvhd,20, 0x10000); writeU32BE(mvhd,24, 0x100);
            writeU32BE(mvhd,28, 0); writeU32BE(mvhd,32, 2); writeU32BE(mvhd,36, 0);
            writeU32BE(mvhd,40, 0); writeU32BE(mvhd,44, 0); writeU32BE(mvhd,48, 0);
            writeU32BE(mvhd,52, 0x00010000); writeU32BE(mvhd,56, 0); writeU32BE(mvhd,60, 0);
            writeU32BE(mvhd,64, 0); writeU32BE(mvhd,68, 0x00010000); writeU32BE(mvhd,72, 0);
            writeU32BE(mvhd,76, 0); writeU32BE(mvhd,80, 0x40); writeU32BE(mvhd,84, 0); writeU32BE(mvhd,88, 0xe0);
            const moov = new Uint8Array(8 + (8 + 108) + mvex.length + (8 + trak.length));
            off = 0;
            off = writeBox(moov, off, 'mvhd', mvhd);
            off = writeBox(moov, off, 'mvex', mvex);
            off = writeBox(moov, off, 'trak', trak);
            const ftypPayload = new Uint8Array([0x69,0x73,0x6f,0x6d, 0,0,0,1, 0x69,0x73,0x6f,0x6d, 0x69,0x73,0x6f,0x35, 0x6d,0x70,0x34,0x31]);
            const ftyp = new Uint8Array(8 + ftypPayload.length);
            writeBox(ftyp, 0, 'ftyp', ftypPayload);
            const out = new Uint8Array(ftyp.length + 8 + moov.length);
            out.set(ftyp, 0);
            writeBox(out, ftyp.length, 'moov', moov);
            return out;
        }
        function buildMp4Fragment(nalBytes, dts, isKeyframe) {
            const len = nalBytes.length;
            const sampleSize = 4 + len;
            const mdatLen = 8 + sampleSize;
            const mdat = new Uint8Array(mdatLen);
            writeU32BE(mdat, 0, mdatLen);
            mdat[4]=0x6d; mdat[5]=0x64; mdat[6]=0x61; mdat[7]=0x74;
            writeU32BE(mdat, 8, len);
            mdat.set(nalBytes, 12);
            const sampleDuration = 3000;
            const trun = new Uint8Array(8 + 4 + 4 + 4 + 4 + 4 + 4);
            writeU32BE(trun, 0, 8 + 4 + 4 + 4 + 4 + 4 + 4);
            trun[4]=0x74; trun[5]=0x72; trun[6]=0x75; trun[7]=0x6e;
            trun[8]=0; trun[9]=0; trun[10]=0x0f; trun[11]=0x01;
            writeU32BE(trun, 12, 1);
            writeU32BE(trun, 16, 0);
            writeU32BE(trun, 20, isKeyframe ? 0x02000000 : 0);
            writeU32BE(trun, 24, sampleDuration);
            writeU32BE(trun, 28, sampleSize);
            const tfhd = new Uint8Array(8 + 16);
            writeU32BE(tfhd, 0, 8 + 16);
            tfhd[4]=0x74; tfhd[5]=0x66; tfhd[6]=0x68; tfhd[7]=0x64;
            tfhd[8]=0; tfhd[9]=0; tfhd[10]=0; tfhd[11]=0x2e;
            writeU32BE(tfhd, 12, 1);
            writeU32BE(tfhd, 16, 1);
            const tfdt = new Uint8Array(8 + 8);
            writeU32BE(tfdt, 0, 8 + 8);
            tfdt[4]=0x74; tfdt[5]=0x66; tfdt[6]=0x64; tfdt[7]=0x74;
            tfdt[8]=0; tfdt[9]=0; tfdt[10]=0; tfdt[11]=0x01;
            writeU32BE(tfdt, 12, Math.round(dts));
            // writeBox æ¯æ¬¡å†™å…¥ 8(å¤´) + payload.lengthï¼Œæ•… traf æ€»é•¿ = ä¸‰ç›’ä¹‹å’Œ
            const traf = new Uint8Array((8 + tfhd.length) + (8 + tfdt.length) + (8 + trun.length));
            off = 0;
            off = writeBox(traf, off, 'tfhd', tfhd);
            off = writeBox(traf, off, 'tfdt', tfdt);
            off = writeBox(traf, off, 'trun', trun);
            const mfhd = new Uint8Array(8 + 4);
            writeU32BE(mfhd, 0, 12);
            mfhd[4]=0x6d; mfhd[5]=0x66; mfhd[6]=0x68; mfhd[7]=0x64;
            writeU32BE(mfhd, 8, 0);
            // moof = box_header(8) + mfhd_box(8+4) + traf_box(8+traf.length)ï¼Œé¿å… writeBox è¶Šç•Œ
            const moof = new Uint8Array(8 + (8 + mfhd.length) + (8 + traf.length));
            let moofOff = writeBox(moof, 0, 'mfhd', mfhd);
            moofOff = writeBox(moof, moofOff, 'traf', traf);
            // trun data_offsetï¼šä»æ®µé¦–åˆ° mdat å†…é¦–å­—èŠ‚ï¼ˆmdat å¤´ 8 å­—èŠ‚åï¼‰ï¼Œ= moof.length + 8
            const trunStartInMoof = 8 + (8 + mfhd.length) + 8 + tfhd.length + 8 + tfdt.length + 8;
            writeU32BE(moof, trunStartInMoof + 16, moof.length + 8);
            const out = new Uint8Array(moof.length + mdat.length);
            out.set(moof, 0);
            out.set(mdat, moof.length);
            return out;
        }
        function initMSEForStream(streamType) {
            if (mseSourceBufferByStream[streamType]) return;
            var existing = mseMediaSourceByStream[streamType];
            if (existing) {
                if (existing.readyState === 'open' || existing.readyState === 'ended') return;
                if (existing.readyState === 'closed') return;
                mseMediaSourceByStream[streamType] = null;
            }
            const sps = h264SPSByStream[streamType];
            const pps = h264PPSByStream[streamType];
            if (!sps || !pps) return;
            const codec = 'avc1.' + [sps[1],sps[2],sps[3]].map(function(x){return x.toString(16).padStart(2,'0');}).join('');
            const wrap = document.getElementById('panel-body-' + streamType);
            const canvasEl = document.getElementById('media-monitor-canvas-' + streamType);
            let videoEl = document.getElementById('media-monitor-mse-video-' + streamType);
            if (!videoEl && wrap) {
                videoEl = document.createElement('video');
                videoEl.id = 'media-monitor-mse-video-' + streamType;
                videoEl.className = 'media-monitor-canvas';
                videoEl.setAttribute('playsinline', '');
                videoEl.setAttribute('muted', '');
                videoEl.style.maxWidth = '100%'; videoEl.style.maxHeight = '180px'; videoEl.style.background = '#1e1e1e';
                wrap.insertBefore(videoEl, wrap.firstChild);
            }
            if (!videoEl) return;
            if (canvasEl) canvasEl.style.display = 'none';
            videoEl.style.display = 'block';
            const ms = new MediaSource();
            mseMediaSourceByStream[streamType] = ms;
            mseHasAppendedKeyframeByStream[streamType] = false;
            mseVideoElByStream[streamType] = videoEl;
            mseDidPlayByStream[streamType] = false;
            mseSequenceByStream[streamType] = 0;
            mseDtsByStream[streamType] = 0;
            mseAppendPendingByStream[streamType] = false;
            const url = URL.createObjectURL(ms);
            videoEl.src = url;
            ms.addEventListener('sourceopen', function() {
                try {
                    if (ms.readyState !== 'open' || mseMediaSourceByStream[streamType] !== ms) return;
                    if (mseSourceBufferByStream[streamType]) return;
                    if (!mseSourceOpenLoggedByStream[streamType]) { mseSourceOpenLoggedByStream[streamType] = true; console.debug('[MSE-init] sourceopen', streamType, 'codec=', codec); }
                    const sb = ms.addSourceBuffer('video/mp4; codecs="' + codec + '"');
                    if (mseMediaSourceByStream[streamType] !== ms) return;
                    mseSourceBufferByStream[streamType] = sb;
                    sb.mode = 'segments';
                    const init = buildMp4InitSegment(sps, pps);
                    if (!init || init.length === 0) {
                        setVideoStreamStatus(streamType, 'MSE ç­‰å¾…å®Œæ•´ SPS/PPSï¼ˆå½“å‰è¿‡çŸ­ï¼‰', true);
                        return;
                    }
                    sb.appendBuffer(new Uint8Array(init));
                    setVideoStreamStatus(streamType, 'MSE å·²å°±ç»ª (' + codec + ')ï¼Œç­‰å¾…å…³é”®å¸§', false);
                    sb.addEventListener('updateend', function onInitEnd() {
                        sb.removeEventListener('updateend', onInitEnd);
                        var pending = msePendingNalsByStream[streamType];
                        if (!mseAppendQueueByStream[streamType]) mseAppendQueueByStream[streamType] = [];
                        if (pending && pending.length) {
                            for (var i = 0; i < pending.length; i++) mseAppendQueueByStream[streamType].push({ nal: pending[i].nal, key: pending[i].isKeyframe });
                            msePendingNalsByStream[streamType] = [];
                            var q = mseAppendQueueByStream[streamType];
                            var keyIdx = -1;
                            for (var k = 0; k < q.length; k++) { if (q[k].key) { keyIdx = k; break; } }
                            if (keyIdx > 0) {
                                var keyItem = q[keyIdx];
                                for (var j = keyIdx; j > 0; j--) q[j] = q[j-1];
                                q[0] = keyItem;
                            }
                            var first = q.shift();
                            if (typeof console !== 'undefined' && console.log) console.log('[MSE-init] flush pending', streamType, 'count=', pending.length, 'keyframeIdx=', keyIdx, 'firstKey=', !!first && first.key);
                            if (first && first.key) {
                                appendMSEFragment(streamType, first.nal, first.key);
                            } else if (first) {
                                q.unshift(first);
                                if (typeof console !== 'undefined' && console.warn) console.warn('[MSE-init] æ— å…³é”®å¸§ï¼Œç­‰å¾…å…³é”®å¸§åå†æ’­', streamType);
                            } else if (typeof console !== 'undefined' && console.warn) console.warn('[MSE-init] init updateend æ— å¾…æ’­ NAL', streamType);
                        }
                    });
                } catch (e) {
                    var msg = (e && (e.message || e.messageDetail || String(e))) || 'æœªçŸ¥';
                    console.error('[MSE-init] SourceBuffer å¤±è´¥:', streamType, 'codec=', codec, 'sps.len=', (sps&&sps.length), 'pps.len=', (pps&&pps.length), 'error=', msg, e);
                    if (e && e.stack) console.error('[MSE-init] stack:', e.stack);
                    setVideoStreamStatus(streamType, 'MSE æ·»åŠ  SourceBuffer å¤±è´¥: ' + msg, true);
                }
            });
        }
        function appendMSEFragment(streamType, nalWithoutStartCode, isKeyframe) {
            const sb = mseSourceBufferByStream[streamType];
            const ms = mseMediaSourceByStream[streamType];
            if (!sb || !ms || ms.readyState !== 'open') {
                if (sb || ms) {
                    mseSourceBufferByStream[streamType] = null;
                    if (ms && (ms.readyState === 'closed' || ms.readyState === 'ended')) mseMediaSourceByStream[streamType] = null;
                }
                return;
            }
            if (!mseAppendQueueByStream[streamType]) mseAppendQueueByStream[streamType] = [];
            if (sb.updating) {
                mseAppendQueueByStream[streamType].push({ nal: nalWithoutStartCode, key: isKeyframe });
                return;
            }
            const dts = mseDtsByStream[streamType] || 0;
            mseDtsByStream[streamType] = dts + 3000;
            mseSequenceByStream[streamType] = (mseSequenceByStream[streamType] || 0) + 1;
            const frag = buildMp4Fragment(nalWithoutStartCode, dts, isKeyframe);
            try {
                sb.appendBuffer(new Uint8Array(frag));
                if (isKeyframe) mseHasAppendedKeyframeByStream[streamType] = true;
                if (isKeyframe) {
                    var v = mseVideoElByStream[streamType];
                    if (v && !mseDidPlayByStream[streamType]) { mseDidPlayByStream[streamType] = true; v.play().catch(function(){}); }
                }
            } catch (e) {
                var msg = (e && (e.message || e.messageDetail || String(e))) || 'æœªçŸ¥';
                console.error('[MSE-frag] appendBuffer å¤±è´¥:', streamType, 'error=', msg, 'frag.len=', frag.length, 'nal.len=', nalWithoutStartCode.length, 'isKeyframe=', isKeyframe);
                if (e && e.stack) console.error('[MSE-frag] stack:', e.stack);
                mseSourceBufferByStream[streamType] = null;
                if (ms.readyState !== 'open') mseMediaSourceByStream[streamType] = null;
                var last = mseInvalidErrorShownAtByStream[streamType] || 0;
                if (Date.now() - last > 5000) {
                    mseInvalidErrorShownAtByStream[streamType] = Date.now();
                    setVideoStreamStatus(streamType, 'MSE å·²å…³é—­æˆ–å¤±æ•ˆï¼Œéœ€é‡æ–°æ”¶å…³é”®å¸§: ' + msg, true);
                }
                return;
            }
            videoFrameCountByStream[streamType] = (videoFrameCountByStream[streamType] || 0) + 1;
            const n = videoFrameCountByStream[streamType] || 0;
            if (n <= 3 || n % 15 === 0) setVideoStreamStatus(streamType, 'MSE å·²è§£ç  ' + n + ' å¸§', false);
            sb.addEventListener('updateend', function onEnd() {
                sb.removeEventListener('updateend', onEnd);
                const q = mseAppendQueueByStream[streamType];
                if (q && q.length) {
                    const next = q.shift();
                    appendMSEFragment(streamType, next.nal, next.key);
                }
            }, { once: true });
        }
        /** åç«¯ç›´æ¥ä¸‹å‘ fMP4 initï¼šåˆ›å»º MSE å¹¶ append åå°æ‰“åŒ…çš„ initï¼Œæ— éœ€å‰ç«¯è§£æ SPS/PPS */
        function initMSEForStreamWithBackendInit(streamType, initBase64, codecFromBackend) {
            const initBytes = Uint8Array.from(atob(initBase64), function(c){ return c.charCodeAt(0); });
            if (!initBytes || initBytes.length === 0) return;
            if (mseSourceBufferByStream[streamType]) {
                try { mseSourceBufferByStream[streamType].appendBuffer(initBytes); } catch (e) { console.warn('[MSE-backend] é‡å¤ init å¿½ç•¥', e); }
                return;
            }
            var existing = mseMediaSourceByStream[streamType];
            if (existing && (existing.readyState === 'open' || existing.readyState === 'ended')) return;
            if (existing && existing.readyState === 'closed') mseMediaSourceByStream[streamType] = null;
            const codec = (codecFromBackend && /^avc1\.[0-9a-fA-F]{6}$/.test(codecFromBackend)) ? codecFromBackend : 'avc1.42001e';
            const wrap = document.getElementById('panel-body-' + streamType);
            const canvasEl = document.getElementById('media-monitor-canvas-' + streamType);
            let videoEl = document.getElementById('media-monitor-mse-video-' + streamType);
            if (!videoEl && wrap) {
                videoEl = document.createElement('video');
                videoEl.id = 'media-monitor-mse-video-' + streamType;
                videoEl.className = 'media-monitor-canvas';
                videoEl.setAttribute('playsinline', '');
                videoEl.setAttribute('muted', '');
                videoEl.style.maxWidth = '100%'; videoEl.style.maxHeight = '180px'; videoEl.style.background = '#1e1e1e';
                wrap.insertBefore(videoEl, wrap.firstChild);
            }
            if (!videoEl) return;
            if (canvasEl) canvasEl.style.display = 'none';
            videoEl.style.display = 'block';
            const ms = new MediaSource();
            const url = URL.createObjectURL(ms);
            videoEl.src = url;
            mseMediaSourceByStream[streamType] = ms;
            mseVideoElByStream[streamType] = videoEl;
            mseDidPlayByStream[streamType] = false;
            mseSequenceByStream[streamType] = 0;
            mseDtsByStream[streamType] = 0;
            ms.addEventListener('sourceopen', function() {
                try {
                    if (ms.readyState !== 'open' || mseMediaSourceByStream[streamType] !== ms) return;
                    if (mseSourceBufferByStream[streamType]) return;
                    if (!mseSourceOpenLoggedByStream[streamType]) { mseSourceOpenLoggedByStream[streamType] = true; console.debug('[MSE-init] sourceopen (backend)', streamType); }
                    const sb = ms.addSourceBuffer('video/mp4; codecs="' + codec + '"');
                    if (mseMediaSourceByStream[streamType] !== ms) return;
                    mseSourceBufferByStream[streamType] = sb;
                    sb.mode = 'segments';
                    sb.appendBuffer(initBytes);
                    setVideoStreamStatus(streamType, 'MSE å·²å°±ç»ª (åå° fMP4)ï¼Œç­‰å¾…å…³é”®å¸§', false);
                    var videoElForPlay = videoEl;
                    setTimeout(function() {
                        if (videoElForPlay && !mseDidPlayByStream[streamType] && mseSourceBufferByStream[streamType]) {
                            mseDidPlayByStream[streamType] = true;
                            videoElForPlay.play().catch(function(){});
                        }
                    }, 1500);
                    sb.addEventListener('updateend', function onInitEnd() {
                        sb.removeEventListener('updateend', onInitEnd);
                        var pending = mseBackendPendingFragmentsByStream[streamType];
                        var q = mseAppendQueueByStream[streamType];
                        if (!q) q = mseAppendQueueByStream[streamType] = [];
                        if (pending && pending.length) {
                            if (typeof console !== 'undefined' && console.log) console.log('[MSE-backend] flush pending', streamType, 'count=', pending.length);
                            mseBackendPendingFragmentsByStream[streamType] = [];
                            for (var i = pending.length - 1; i >= 0; i--) q.unshift({ bytes: pending[i].bytes, key: pending[i].key });
                        }
                        if (q.length) {
                            var keyIdx = -1;
                            for (var k = 0; k < q.length; k++) { if (q[k].key) { keyIdx = k; break; } }
                            if (keyIdx > 0) {
                                var keyItem = q[keyIdx];
                                for (var j = keyIdx; j > 0; j--) q[j] = q[j-1];
                                q[0] = keyItem;
                            }
                            var first = q.shift();
                            if (first) appendMSEFragmentBytesRaw(streamType, first.bytes, first.key);
                        } else if (typeof console !== 'undefined' && console.warn) console.warn('[MSE-backend] init updateend æ— å¾…æ’­ fragment', streamType);
                    }, { once: true });
                } catch (e) {
                    var msg = (e && (e.message || e.messageDetail || String(e))) || 'æœªçŸ¥';
                    console.error('[MSE-backend] init append å¤±è´¥:', streamType, msg);
                    setVideoStreamStatus(streamType, 'MSE init å¤±è´¥: ' + msg, true);
                }
            });
        }
        /** åç«¯ä¸‹å‘çš„ fMP4 fragmentï¼šç›´æ¥ appendï¼Œå…³é”®å¸§æ—¶è§¦å‘æ’­æ”¾ */
        function appendMSEFragmentBytes(streamType, fragmentBase64, isKeyframe) {
            const frag = Uint8Array.from(atob(fragmentBase64), function(c){ return c.charCodeAt(0); });
            if (!frag || frag.length === 0) return;
            appendMSEFragmentBytesRaw(streamType, frag, isKeyframe);
        }
        function appendMSEFragmentBytesRaw(streamType, frag, isKeyframe) {
            const sb = mseSourceBufferByStream[streamType];
            const ms = mseMediaSourceByStream[streamType];
            if (!ms || ms.readyState !== 'open') return;
            if (!sb) {
                if (!mseBackendPendingFragmentsByStream[streamType]) mseBackendPendingFragmentsByStream[streamType] = [];
                mseBackendPendingFragmentsByStream[streamType].push({ bytes: frag, key: isKeyframe });
                if (mseBackendPendingFragmentsByStream[streamType].length > 500) mseBackendPendingFragmentsByStream[streamType].shift();
                return;
            }
            if (sb.updating) {
                if (!mseAppendQueueByStream[streamType]) mseAppendQueueByStream[streamType] = [];
                mseAppendQueueByStream[streamType].push({ bytes: frag, key: isKeyframe });
                return;
            }
            try {
                if (typeof console !== 'undefined' && console.log && (videoFrameCountByStream[streamType] || 0) < 2) console.log('[MSE-frag] append', streamType, 'len=', frag.length);
                sb.appendBuffer(frag);
                videoFrameCountByStream[streamType] = (videoFrameCountByStream[streamType] || 0) + 1;
                var n = videoFrameCountByStream[streamType] || 0;
                if (n <= 3 || n % 15 === 0) setVideoStreamStatus(streamType, 'MSE å·²è§£ç  ' + n + ' å¸§', false);
                var v = mseVideoElByStream[streamType];
                if (v && !mseDidPlayByStream[streamType]) {
                    mseDidPlayByStream[streamType] = true;
                    v.play().catch(function(){});
                }
            } catch (e) {
                console.error('[MSE-frag] appendBuffer å¤±è´¥:', streamType, 'len=' + (frag && frag.length), e && e.name, e && e.message);
                setVideoStreamStatus(streamType, 'MSE append å¤±è´¥: ' + (e && (e.name || e.message) || e), true);
                sb.addEventListener('updateend', function onEnd() {
                    sb.removeEventListener('updateend', onEnd);
                    var q = mseAppendQueueByStream[streamType];
                    if (q && q.length) { var next = q.shift(); if (next) appendMSEFragmentBytesRaw(streamType, next.bytes, next.key); }
                }, { once: true });
                return;
            }
            sb.addEventListener('updateend', function onEnd() {
                sb.removeEventListener('updateend', onEnd);
                var q = mseAppendQueueByStream[streamType];
                if (q && q.length) {
                    var next = q.shift();
                    if (next && next.bytes) appendMSEFragmentBytesRaw(streamType, next.bytes, next.key);
                    else if (next && next.nal) appendMSEFragment(streamType, next.nal, next.key);
                }
            }, { once: true });
        }
        
        function initVideoDecoderIfReady() {
            // å¦‚æœè§£ç å™¨å·²å­˜åœ¨ä¸”çŠ¶æ€æ­£å¸¸ï¼Œä¸é‡å¤åˆå§‹åŒ–
            if (videoDecoder && videoDecoder.state === 'configured') return;
            // å¦‚æœè§£ç å™¨å­˜åœ¨ä½†çŠ¶æ€å¼‚å¸¸ï¼Œé‡ç½®å®ƒ
            if (videoDecoder && videoDecoder.state !== 'configured') {
                console.warn('[MediaMonitor] è§£ç å™¨çŠ¶æ€å¼‚å¸¸ï¼Œé‡ç½®:', videoDecoder.state);
                try {
                    if (videoDecoder.state === 'configured') videoDecoder.reset();
                } catch (e) {}
                videoDecoder = null;
            }
            if (!h264SPS || !h264PPS || !window.VideoDecoder) {
                if (!window.VideoDecoder) {
                    console.warn('[MediaMonitor] VideoDecoder API ä¸å¯ç”¨');
                }
                return;
            }
            try {
                const description = buildAvcC(h264SPS, h264PPS);
                console.log('[MediaMonitor] åˆå§‹åŒ– H.264 è§£ç å™¨ï¼ŒSPSé•¿åº¦:', h264SPS.length, 'PPSé•¿åº¦:', h264PPS.length);
                videoDecoder = new VideoDecoder({
                    output: (frame) => {
                        try {
                            if (videoCtx && videoCanvas) {
                                // åŠ¨æ€è°ƒæ•´ canvas å°ºå¯¸ä»¥åŒ¹é…è§†é¢‘å¸§
                                if (videoCanvas.width !== frame.displayWidth || videoCanvas.height !== frame.displayHeight) {
                                    videoCanvas.width = frame.displayWidth || 640;
                                    videoCanvas.height = frame.displayHeight || 480;
                                    console.log('[MediaMonitor] Canvas å°ºå¯¸å·²æ›´æ–°:', videoCanvas.width, 'x', videoCanvas.height);
                                }
                                videoCtx.drawImage(frame, 0, 0, videoCanvas.width, videoCanvas.height);
                                videoFrameCount++;
                                const infoEl = document.getElementById('media-monitor-player-info');
                                if (infoEl && videoFrameCount % 30 === 0) {
                                    infoEl.textContent = `è§†é¢‘æµï¼šå·²è§£ç  ${videoFrameCount} å¸§ (${frame.displayWidth}x${frame.displayHeight})`;
                                }
                            }
                            frame.close();
                        } catch (e) {
                            console.error('[MediaMonitor] ç»˜åˆ¶å¸§å¤±è´¥:', e);
                            frame.close();
                        }
                    },
                    error: (e) => {
                        console.error('[MediaMonitor] VideoDecoder è§£ç é”™è¯¯:', e);
                        const infoEl = document.getElementById('media-monitor-player-info');
                        if (infoEl) infoEl.textContent = `è§†é¢‘æµï¼šè§£ç é”™è¯¯ - ${e.message || e}`;
                        // è§£ç é”™è¯¯æ—¶é‡ç½®è§£ç å™¨ï¼Œç­‰å¾…é‡æ–°åˆå§‹åŒ–
                        videoDecoder = null;
                    }
                });
                const profile = h264SPS[1];
                const level = h264SPS[3];
                const codecStr = `avc1.${profile.toString(16).padStart(2, '0')}${h264SPS[2].toString(16).padStart(2, '0')}${level.toString(16).padStart(2, '0')}`;
                console.log('[MediaMonitor] é…ç½®è§£ç å™¨ï¼Œcodec:', codecStr);
                videoDecoder.configure({
                    codec: codecStr,
                    codedWidth: 640,  // åˆå§‹å°ºå¯¸ï¼Œå®é™…ä¼šä»å¸§ä¸­è·å–
                    codedHeight: 480,
                    description: description
                });
                // é…ç½®æ˜¯å¼‚æ­¥çš„ï¼Œæ£€æŸ¥çŠ¶æ€
                const checkState = () => {
                    if (videoDecoder) {
                        console.log('[MediaMonitor] è§£ç å™¨çŠ¶æ€:', videoDecoder.state);
                        const infoEl = document.getElementById('media-monitor-player-info');
                        if (videoDecoder.state === 'configured') {
                            if (infoEl) infoEl.textContent = `è§†é¢‘æµï¼šè§£ç å™¨å·²å°±ç»ª (${codecStr})ï¼Œç­‰å¾…å…³é”®å¸§â€¦`;
                            console.log('[MediaMonitor] H.264 è§£ç å™¨å·²å°±ç»ª:', codecStr);
                        } else if (videoDecoder.state === 'closed') {
                            if (infoEl) infoEl.textContent = `è§†é¢‘æµï¼šè§£ç å™¨å·²å…³é—­`;
                            videoDecoder = null;
                        }
                    }
                };
                // å»¶è¿Ÿæ£€æŸ¥çŠ¶æ€ï¼ˆé…ç½®æ˜¯å¼‚æ­¥çš„ï¼‰
                setTimeout(checkState, 100);
                const infoEl = document.getElementById('media-monitor-player-info');
                if (infoEl) infoEl.textContent = `è§†é¢‘æµï¼šæ­£åœ¨åˆå§‹åŒ–è§£ç å™¨ (${codecStr})â€¦`;
            } catch (e) {
                console.error('[MediaMonitor] VideoDecoder åˆå§‹åŒ–å¤±è´¥:', e);
                const infoEl = document.getElementById('media-monitor-player-info');
                if (infoEl) infoEl.textContent = `è§†é¢‘æµï¼šè§£ç å™¨åˆå§‹åŒ–å¤±è´¥ - ${e.message || e}`;
                videoDecoder = null;
            }
        }
        
        function decodeAndDrawH264(nalWithStartCode, timestampMs) {
            if (!videoDecoder) {
                console.warn('[MediaMonitor] è§£ç å™¨æœªåˆå§‹åŒ–');
                return;
            }
            if (videoDecoder.state !== 'configured') {
                console.warn('[MediaMonitor] è§£ç å™¨çŠ¶æ€ä¸æ˜¯ configured:', videoDecoder.state);
                // å¦‚æœçŠ¶æ€æ˜¯ closedï¼Œå°è¯•é‡æ–°åˆå§‹åŒ–
                if (videoDecoder.state === 'closed') {
                    videoDecoder = null;
                    initVideoDecoderIfReady();
                }
                return;
            }
            const nalType = nalWithStartCode[4] !== undefined ? (nalWithStartCode[4] & 0x1F) : (nalWithStartCode[3] & 0x1F);
            if (nalType !== 1 && nalType !== 5) {
                console.warn('[MediaMonitor] å¿½ç•¥éå¸§ NAL ç±»å‹:', nalType);
                return;
            }
            try {
                // WebCodecs EncodedVideoChunk çš„ timestamp æ˜¯å¾®ç§’
                const timestampUs = typeof timestampMs === 'number' ? timestampMs * 1000 : Date.now() * 1000;
                const chunk = new EncodedVideoChunk({
                    type: nalType === 5 ? 'key' : 'delta',
                    timestamp: timestampUs,
                    duration: 0,
                    data: nalWithStartCode
                });
                videoDecoder.decode(chunk);
                if (nalType === 5) {
                    console.log('[MediaMonitor] å·²å‘é€ IDR å¸§åˆ°è§£ç å™¨');
                }
            } catch (e) {
                console.error('[MediaMonitor] è§£ç å¤±è´¥:', e, 'NALç±»å‹:', nalType, 'æ•°æ®é•¿åº¦:', nalWithStartCode.length);
                const infoEl = document.getElementById('media-monitor-player-info');
                if (infoEl) infoEl.textContent = `è§†é¢‘æµï¼šè§£ç å¤±è´¥ - ${e.message || e}`;
            }
        }
        
        // H.264 NALå•å…ƒæå–ï¼ˆæ”¯æŒä¸¤ç§æ ¼å¼ï¼‰
        // 1) èµ·å§‹ç æ ¼å¼ï¼š0x00 0x00 0x01 æˆ– 0x00 0x00 0x00 0x01
        // 2) RTP æ ¼å¼ï¼šæ— èµ·å§‹ç ï¼ŒSingle NAL æ—¶é¦–å­—èŠ‚ä¸º NAL å¤´(type=ä½5ä½)ï¼›FU-A æ—¶é¦–å­—èŠ‚ç±»å‹28ï¼ŒçœŸå®ç±»å‹åœ¨ payload[1]&0x1F
        function extractH264NALUnits(payload) {
            const nals = [];
            let i = 0;
            
            while (i < payload.length) {
                let startCodeLen = 0;
                if (i + 3 < payload.length && 
                    payload[i] === 0x00 && payload[i + 1] === 0x00 && 
                    payload[i + 2] === 0x00 && payload[i + 3] === 0x01) {
                    startCodeLen = 4;
                } else if (i + 2 < payload.length && 
                           payload[i] === 0x00 && payload[i + 1] === 0x00 && payload[i + 2] === 0x01) {
                    startCodeLen = 3;
                }
                
                if (startCodeLen > 0) {
                    i += startCodeLen;
                    const start = i;
                    while (i < payload.length) {
                        if (i + 3 < payload.length && 
                            payload[i] === 0x00 && payload[i + 1] === 0x00 && 
                            payload[i + 2] === 0x00 && payload[i + 3] === 0x01) break;
                        if (i + 2 < payload.length && 
                            payload[i] === 0x00 && payload[i + 1] === 0x00 && payload[i + 2] === 0x01) break;
                        i++;
                    }
                    if (i > start) nals.push(payload.slice(start, i));
                    continue;
                }
                
                // RTP å•åŒ…ï¼šæ— èµ·å§‹ç ï¼Œæ•´åŒ…ä¸ºä¸€ä¸ª NAL æˆ– FU-A ç‰‡ï¼ˆå¸¸è§äº RTP æ‰“åŒ…ï¼Œæ—  0x00 0x00 0x01ï¼‰
                if (payload.length - i >= 1) {
                    const first = payload[i] & 0x1F;
                    if (first >= 1 && first <= 23) {
                        nals.push(payload.slice(i));
                        break;
                    }
                    if ((first === 28 || first === 29) && payload.length - i >= 2) {
                        const realType = payload[i + 1] & 0x1F;
                        nals.push(new Uint8Array([realType]));
                        break;
                    }
                    // å…œåº•ï¼šä»»æ„éèµ·å§‹ç é¦–å­—èŠ‚è§†ä¸º Single NAL ç±»å‹
                    nals.push(payload.slice(i));
                    break;
                }
                i++;
            }
            
            return nals;
        }
        
        let audioBufferIndex = 0;
        let lastVideoTime = 0;  // è§†é¢‘æ—¶é—´æˆ³ï¼ˆå¾®ç§’ï¼‰
        
        function handleRtpPayload(payloadB64, streamType, codec, payloadType) {
            try {
                const payload = Uint8Array.from(atob(payloadB64), c => c.charCodeAt(0));
                
                if (streamType.startsWith('audio')) {
                    // éŸ³é¢‘å¤„ç†ï¼šG.711 (PCMU/PCMA) è§£ç 
                    if (audioContext && audioContext.state === 'running') {
                        const infoEl = document.getElementById('media-monitor-player-info');
                        
                        // æ£€æŸ¥ç¼–è§£ç ç±»å‹
                        if (codec === 'PCMU' || codec === 'PCMA' || payloadType === 0 || payloadType === 8) {
                            try {
                                // ç¡®å®šç¼–è§£ç ç±»å‹ï¼ˆä¼˜å…ˆä½¿ç”¨payloadTypeï¼Œå› ä¸ºæ›´å‡†ç¡®ï¼‰
                                let actualCodec = codec;
                                if (!actualCodec || actualCodec === 'UNKNOWN') {
                                    actualCodec = (payloadType === 0) ? 'PCMU' : 'PCMA';
                                }
                                
                                // è§£ç G.711åˆ°PCM
                                const pcmSamples = decodeG711(payload, actualCodec);
                                
                                // é‡é‡‡æ ·ï¼šG.711æ˜¯8kHzï¼Œæµè§ˆå™¨é€šå¸¸éœ€è¦44.1kHzæˆ–48kHz
                                const targetSampleRate = audioContext.sampleRate;
                                const resampledSamples = resampleAudio8kTo44k(pcmSamples, 8000, targetSampleRate);
                                
                                // å°†è§£ç åçš„éŸ³é¢‘æ•°æ®åŠ å…¥é˜Ÿåˆ—ï¼Œç”±ScriptProcessorNodeè¿ç»­æ’­æ”¾
                                if (isPlayingAudio && audioScriptProcessor) {
                                    audioBufferQueue.push(resampledSamples);
                                    
                                    // é™åˆ¶é˜Ÿåˆ—å¤§å°ï¼Œé¿å…å†…å­˜æº¢å‡ºï¼ˆä¿æŒçº¦1ç§’çš„ç¼“å†²ï¼‰
                                    const maxQueueSize = Math.ceil(targetSampleRate / 8000 * 50); // çº¦1ç§’çš„ç¼“å†²
                                    if (audioBufferQueue.length > maxQueueSize) {
                                        // ä¸¢å¼ƒæœ€è€çš„æ•°æ®ï¼Œä¿æŒæµç•…æ’­æ”¾
                                        const removeCount = audioBufferQueue.length - maxQueueSize;
                                        for (let i = 0; i < removeCount; i++) {
                                            audioBufferQueue.shift();
                                        }
                                    }
                                    
                                    // æ›´æ–°çŠ¶æ€ä¿¡æ¯ï¼ˆå‡å°‘æ›´æ–°é¢‘ç‡ï¼‰
                                    if (audioBufferQueue.length % 10 === 0 || audioBufferQueue.length === 1) {
                                        infoEl.textContent = `éŸ³é¢‘æµï¼šæ­£åœ¨æ’­æ”¾ (${actualCodec}, ${payload.length}å­—èŠ‚, é˜Ÿåˆ—:${audioBufferQueue.length})`;
                                    }
                                } else {
                                    infoEl.textContent = `éŸ³é¢‘æµï¼šæ’­æ”¾å™¨æœªå°±ç»ª`;
                                }
                            } catch (e) {
                                console.error('[MediaMonitor] éŸ³é¢‘è§£ç å¤±è´¥:', e);
                                infoEl.textContent = `éŸ³é¢‘æµï¼šè§£ç é”™è¯¯ - ${e.message}`;
                            }
                        } else {
                            infoEl.textContent = `éŸ³é¢‘æµï¼šä¸æ”¯æŒçš„ç¼–è§£ç  ${codec || 'UNKNOWN'} (payload type: ${payloadType})`;
                        }
                    }
                } else if (streamType.startsWith('video')) {
                    const infoEl = document.getElementById('media-monitor-player-info');
                    if (codec !== 'H264' && payloadType !== 96) {
                        infoEl.textContent = `è§†é¢‘æµï¼šä¸æ”¯æŒçš„ç¼–è§£ç  ${codec || 'UNKNOWN'} (payload type: ${payloadType})`;
                    } else {
                        try {
                            const START_CODE = new Uint8Array([0, 0, 0, 1]);
                            const pushNAL = (nalBytes, nalType) => {
                                if (nalType === 7) {
                                    h264SPS = nalBytes;
                                    const infoEl = document.getElementById('media-monitor-player-info');
                                    if (infoEl) infoEl.textContent = `è§†é¢‘æµï¼šå·²æ”¶åˆ° SPS | PPS:${!!h264PPS} | å·²è§£ç  ${videoFrameCount} å¸§`;
                                    initVideoDecoderIfReady();
                                } else if (nalType === 8) {
                                    h264PPS = nalBytes;
                                    const infoEl = document.getElementById('media-monitor-player-info');
                                    if (infoEl) infoEl.textContent = `è§†é¢‘æµï¼šå·²æ”¶åˆ° PPS | SPS:${!!h264SPS} | å·²è§£ç  ${videoFrameCount} å¸§`;
                                    initVideoDecoderIfReady();
                                } else if (nalType === 1 || nalType === 5) {
                                    // ç¡®ä¿è§£ç å™¨å·²åˆå§‹åŒ–
                                    if (!videoDecoder || videoDecoder.state !== 'configured') {
                                        initVideoDecoderIfReady();
                                        const infoEl = document.getElementById('media-monitor-player-info');
                                        if (infoEl) {
                                            const decoderReady = videoDecoder && videoDecoder.state === 'configured';
                                            infoEl.textContent = `è§†é¢‘æµï¼šæ”¶åˆ° ${nalType === 5 ? 'IDR' : 'éIDR'} å¸§ | SPS:${!!h264SPS} PPS:${!!h264PPS} | è§£ç å™¨:${decoderReady ? 'å°±ç»ª' : 'æœªå°±ç»ª'}`;
                                        }
                                        // å³ä½¿è§£ç å™¨æœªå°±ç»ªï¼Œä¹Ÿå°è¯•è§£ç ï¼ˆå¯èƒ½é…ç½®æ­£åœ¨è¿›è¡Œä¸­ï¼‰
                                    }
                                    const withStart = new Uint8Array(START_CODE.length + nalBytes.length);
                                    withStart.set(START_CODE, 0);
                                    withStart.set(nalBytes, START_CODE.length);
                                    // æ—¶é—´æˆ³ï¼šWebCodecs éœ€è¦å¾®ç§’ï¼Œå‡è®¾ 30fpsï¼Œæ¯å¸§çº¦ 33333 å¾®ç§’
                                    const frameIntervalUs = 1000000 / 30;  // 30fps = 33333 å¾®ç§’/å¸§
                                    const ts = (lastVideoTime || 0) + frameIntervalUs;
                                    lastVideoTime = ts;
                                    decodeAndDrawH264(withStart, ts / 1000);  // è½¬æ¢ä¸ºæ¯«ç§’ä¼ ç»™å‡½æ•°ï¼Œå‡½æ•°å†…éƒ¨å†è½¬å¾®ç§’
                                    const infoEl = document.getElementById('media-monitor-player-info');
                                    if (videoDecoder && videoDecoder.state === 'configured') {
                                        if (infoEl && videoFrameCount % 10 === 0) {
                                            infoEl.textContent = `è§†é¢‘æµï¼šå·²è§£ç  ${videoFrameCount} å¸§ (ç±»å‹${nalType === 5 ? 'IDR' : 'éIDR'})`;
                                        }
                                    }
                                }
                            };
                            if (payload.length < 2) return;
                            const b0 = payload[0] & 0x1F;
                            if (b0 >= 1 && b0 <= 23) {
                                if (b0 === 7 || b0 === 8 || b0 === 1 || b0 === 5) {
                                    pushNAL(payload, b0);
                                }
                                if (b0 !== 7 && b0 !== 8) {
                                    const hasSPS = !!h264SPS;
                                    const hasPPS = !!h264PPS;
                                    const decoderReady = videoDecoder && videoDecoder.state === 'configured';
                                    const decoderState = videoDecoder ? videoDecoder.state : 'æœªåˆå§‹åŒ–';
                                    if (!decoderReady && (b0 === 1 || b0 === 5)) {
                                        console.log(`[MediaMonitor] æ”¶åˆ° ${b0 === 5 ? 'IDR' : 'éIDR'} å¸§ï¼Œè§£ç å™¨çŠ¶æ€: ${decoderState}, SPS:${hasSPS}, PPS:${hasPPS}`);
                                        infoEl.textContent = `è§†é¢‘æµï¼šå·²æ¥æ”¶ NAL ç±»å‹${b0} | SPS:${hasSPS} PPS:${hasPPS} | è§£ç å™¨:${decoderState}`;
                                        // å¦‚æœ SPS/PPS éƒ½æœ‰äº†ä½†è§£ç å™¨æœªå°±ç»ªï¼Œå°è¯•é‡æ–°åˆå§‹åŒ–
                                        if (hasSPS && hasPPS && !decoderReady) {
                                            console.log('[MediaMonitor] SPS/PPS å·²å°±ç»ªï¼Œå°è¯•åˆå§‹åŒ–è§£ç å™¨');
                                            initVideoDecoderIfReady();
                                        }
                                    } else if (b0 !== 1 && b0 !== 5) {
                                        infoEl.textContent = `è§†é¢‘æµï¼šå·²æ¥æ”¶ NAL ç±»å‹${b0} | SPS:${hasSPS} PPS:${hasPPS} | å·²è§£ç  ${videoFrameCount} å¸§`;
                                    }
                                }
                            } else if ((b0 === 28 || b0 === 29) && payload.length >= 3) {
                                const fuHeader = payload[1];
                                const realType = fuHeader & 0x1F;
                                const s = (fuHeader & 0x80) !== 0;
                                const e = (fuHeader & 0x40) !== 0;
                                const nalHeader = (payload[0] & 0xE0) | realType;
                                const fragment = payload.slice(2);
                                if (s) {
                                    h264FUABuffer = { nalHeader: nalHeader, chunks: [fragment] };
                                } else if (h264FUABuffer) {
                                    h264FUABuffer.chunks.push(fragment);
                                }
                                if (e && h264FUABuffer) {
                                    let len = 0;
                                    for (const c of h264FUABuffer.chunks) len += c.length;
                                    const full = new Uint8Array(1 + len);
                                    full[0] = h264FUABuffer.nalHeader;
                                    let off = 1;
                                    for (const c of h264FUABuffer.chunks) {
                                        full.set(c, off);
                                        off += c.length;
                                    }
                                    pushNAL(full, realType);
                                    h264FUABuffer = null;
                                    if (realType !== 7 && realType !== 8) {
                                        const decoderReady = videoDecoder && videoDecoder.state === 'configured';
                                        if (!decoderReady && (realType === 1 || realType === 5)) {
                                            infoEl.textContent = `è§†é¢‘æµï¼šFU-A ç±»å‹${realType} | SPS:${!!h264SPS} PPS:${!!h264PPS} | ç­‰å¾…è§£ç å™¨å°±ç»ª`;
                                        }
                                    }
                                } else if (h264FUABuffer) {
                                    infoEl.textContent = `è§†é¢‘æµï¼šFU-A é‡ç»„ä¸­ (ç±»å‹${realType}) | SPS:${!!h264SPS} PPS:${!!h264PPS}`;
                                }
                            } else {
                                infoEl.textContent = `è§†é¢‘æµï¼šå·²æ¥æ”¶ ${payload.length} å­—èŠ‚ | SPS:${!!h264SPS} PPS:${!!h264PPS} | å·²è§£ç  ${videoFrameCount} å¸§`;
                            }
                        } catch (e) {
                            console.error('[MediaMonitor] è§†é¢‘å¤„ç†å¤±è´¥:', e);
                            infoEl.textContent = `è§†é¢‘æµï¼šå¤„ç†é”™è¯¯ - ${e.message}`;
                        }
                    }
                }
            } catch (e) {
                console.error('[MediaMonitor] å¤„ç†RTP payloadå¤±è´¥:', e);
            }
        }
        
        function initVideoDecoderIfReadyForStream(streamType) {
            const sps = h264SPSByStream[streamType];
            const pps = h264PPSByStream[streamType];
            let dec = videoDecodersByStream[streamType];
            if (dec && dec.state === 'configured') return;
            if (dec) { try { if (dec.state === 'configured') dec.reset(); } catch (e) {} dec = null; videoDecodersByStream[streamType] = null; videoDecoderHasReceivedKeyframeByStream[streamType] = false; }
            if (!sps || !pps) return;
            if (!window.VideoDecoder) {
                if (!mseInitLoggedByStream[streamType]) { mseInitLoggedByStream[streamType] = true; console.debug('[MSE-debug] ä½¿ç”¨ MSE å›é€€', streamType); }
                setVideoStreamStatus(streamType, 'ä½¿ç”¨ MSE å›é€€ï¼ˆè‹¥æ— æ³•æ˜¾ç¤ºè¯·ç”¨ Chrome/Edgeï¼‰', false);
                if (!msePendingNalsByStream[streamType]) msePendingNalsByStream[streamType] = [];
                initMSEForStream(streamType);
                return;
            }
            try {
                const description = buildAvcC(sps, pps);
                const canvasEl = document.getElementById('media-monitor-canvas-' + streamType);
                const ctx = canvasEl ? canvasEl.getContext('2d') : null;
                dec = new VideoDecoder({
                    output: (frame) => {
                        try {
                            if (ctx && canvasEl) {
                                if (canvasEl.width !== frame.displayWidth || canvasEl.height !== frame.displayHeight) {
                                    canvasEl.width = frame.displayWidth || 320;
                                    canvasEl.height = frame.displayHeight || 240;
                                }
                                ctx.drawImage(frame, 0, 0, canvasEl.width, canvasEl.height);
                                videoFrameCountByStream[streamType] = (videoFrameCountByStream[streamType] || 0) + 1;
                                const n = videoFrameCountByStream[streamType] || 0;
                                if (n <= 3 || n % 15 === 0) setVideoStreamStatus(streamType, 'å·²è§£ç  ' + n + ' å¸§ | ' + getVideoStreamStatusLine(streamType), false);
                            }
                            frame.close();
                        } catch (e) {
                            frame.close();
                            setVideoStreamStatus(streamType, 'ç»˜åˆ¶å¸§å¤±è´¥: ' + (e.message || e), true);
                        }
                    },
                    error: (e) => {
                        const msg = (e && (e.message || e.messageDetail || String(e))) || 'æœªçŸ¥';
                        console.warn('[MediaMonitor]', streamType, 'decode error:', e);
                        videoDecodersByStream[streamType] = null;
                        videoDecoderHasReceivedKeyframeByStream[streamType] = false;
                        setVideoStreamStatus(streamType, 'è§£ç å™¨æŠ¥é”™: ' + msg + ' | ' + getVideoStreamStatusLine(streamType), true);
                    }
                });
                const profile = sps[1];
                const level = sps[3];
                const codecStr = 'avc1.' + profile.toString(16).padStart(2,'0') + sps[2].toString(16).padStart(2,'0') + level.toString(16).padStart(2,'0');
                dec.configure({ codec: codecStr, codedWidth: 320, codedHeight: 240, description: description });
                videoDecodersByStream[streamType] = dec;
                videoDecoderHasReceivedKeyframeByStream[streamType] = false;
                setVideoStreamStatus(streamType, 'è§£ç å™¨å°±ç»ª (' + codecStr + ') ç­‰å¾…å…³é”®å¸§ | ' + getVideoStreamStatusLine(streamType), false);
            } catch (e) {
                const msg = (e && e.message) ? e.message : String(e);
                console.warn('[MediaMonitor] init decoder', streamType, e);
                setVideoStreamStatus(streamType, 'åˆå§‹åŒ–è§£ç å™¨å¤±è´¥: ' + msg + ' | ' + getVideoStreamStatusLine(streamType), true);
            }
        }
        
        function decodeAndDrawH264ForStream(streamType, nalWithStartCode, timestampMs) {
            const dec = videoDecodersByStream[streamType];
            if (!dec || dec.state !== 'configured') {
                if (!videoStreamDebug[streamType]) videoStreamDebug[streamType] = {};
                videoStreamDebug[streamType].lastError = 'è§£ç å™¨æœªå°±ç»ª(state=' + (dec ? dec.state : 'null') + ')';
                return;
            }
            const nalType = nalWithStartCode[4] !== undefined ? (nalWithStartCode[4] & 0x1F) : (nalWithStartCode[3] & 0x1F);
            if (nalType !== 1 && nalType !== 5) return;
            // æœªé€å…³é”®å¸§å‰ä¸é€ P å¸§ï¼Œé¿å… "Key frame is required" / "Unable to determine size of bitstream buffer"
            const hasKey = !!videoDecoderHasReceivedKeyframeByStream[streamType];
            if (nalType === 1 && !hasKey) return;
            // Chrome VideoDecoder(avc1) æœŸæœ› AVCCï¼ˆ4 å­—èŠ‚å¤§ç«¯é•¿åº¦ + NALï¼‰ï¼Œæ­¤å¤„å°† Annex Bï¼ˆ0,0,0,1 + NALï¼‰è½¬ä¸º AVCC
            const nalLen = nalWithStartCode.length - 4;
            const avcc = new Uint8Array(4 + nalLen);
            const view = new DataView(avcc.buffer);
            view.setUint32(0, nalLen, false);
            avcc.set(nalWithStartCode.subarray(4), 4);
            try {
                const timestampUs = (typeof timestampMs === 'number' ? timestampMs : 0) * 1000;
                dec.decode(new EncodedVideoChunk({ type: nalType === 5 ? 'key' : 'delta', timestamp: timestampUs, duration: 0, data: avcc }));
                if (nalType === 5) videoDecoderHasReceivedKeyframeByStream[streamType] = true;
                if (!videoStreamDebug[streamType]) videoStreamDebug[streamType] = {};
                videoStreamDebug[streamType].framesSentToDecoder = (videoStreamDebug[streamType].framesSentToDecoder || 0) + 1;
                videoStreamDebug[streamType].lastNal = nalType === 5 ? 'IDR' : 'éIDR';
            } catch (e) {
                const msg = (e && e.message) ? e.message : String(e);
                setVideoStreamStatus(streamType, 'decode() å¼‚å¸¸: ' + msg + ' | ' + getVideoStreamStatusLine(streamType), true);
            }
        }
        
        function handleRtpPayloadForStream(streamType, payloadB64, codec, payloadType) {
            try {
                const payload = Uint8Array.from(atob(payloadB64), c => c.charCodeAt(0));
                if (streamType.startsWith('audio')) {
                    if (!audioContext || audioContext.state !== 'running') return;
                    if (codec !== 'PCMU' && codec !== 'PCMA' && payloadType !== 0 && payloadType !== 8) return;
                    const actualCodec = (payloadType === 0) ? 'PCMU' : 'PCMA';
                    const pcmSamples = decodeG711(payload, actualCodec);
                    const targetSampleRate = audioContext.sampleRate;
                    const resampledSamples = resampleAudio8kTo44k(pcmSamples, 8000, targetSampleRate);
                    const q = audioBufferQueues[streamType];
                    if (q) {
                        q.push(resampledSamples);
                        const maxQueueSize = Math.ceil(targetSampleRate / 8000 * 12);  // ~0.24s ç¼“å†²ï¼Œé™ä½å»¶è¿Ÿ
                        if (q.length > maxQueueSize) { for (let i = 0; i < q.length - maxQueueSize; i++) q.shift(); }
                    }
                } else if (streamType.startsWith('video')) {
                    if (codec !== 'H264' || (payloadType !== undefined && payloadType !== 96)) {
                        setVideoStreamStatus(streamType, 'é H264 ç¼–è§£ç : ' + (codec || '') + ' pt=' + payloadType + ' | ' + getVideoStreamStatusLine(streamType), true);
                        return;
                    }
                    const START_CODE = new Uint8Array([0, 0, 0, 1]);
                    const st = streamType;
                    if (payload.length < 2) {
                        setVideoStreamStatus(streamType, 'RTP è½½è·è¿‡çŸ­(' + payload.length + ') | ' + getVideoStreamStatusLine(st), true);
                        return;
                    }
                    const b0 = payload[0] & 0x1F;
                    if (b0 >= 1 && b0 <= 23) {
                        if (b0 === 7) {
                            if (!h264SPSByStream[st] || payload.length > h264SPSByStream[st].length) h264SPSByStream[st] = payload.slice(0);
                            if (!mseSPSLoggedByStream[st]) { mseSPSLoggedByStream[st] = true; console.debug('[MSE-debug] SPS æ”¶åˆ°', st, 'len=', payload.length); }
                            setVideoStreamStatus(st, 'å·²æ”¶ SPS (' + payload.length + 'B) | ' + getVideoStreamStatusLine(st), false);
                            initVideoDecoderIfReadyForStream(st);
                        } else if (b0 === 8) {
                            if (!h264PPSByStream[st] || payload.length > h264PPSByStream[st].length) h264PPSByStream[st] = payload.slice(0);
                            if (!msePPSLoggedByStream[st]) { msePPSLoggedByStream[st] = true; console.debug('[MSE-debug] PPS æ”¶åˆ°', st, 'len=', payload.length); }
                            setVideoStreamStatus(st, 'å·²æ”¶ PPS (' + payload.length + 'B) | ' + getVideoStreamStatusLine(st), false);
                            initVideoDecoderIfReadyForStream(st);
                        } else if (b0 === 1 || b0 === 5) {
                            initVideoDecoderIfReadyForStream(st);
                            if (mseSourceBufferByStream[st]) {
                                var needKey = !mseHasAppendedKeyframeByStream[st];
                                if (needKey && (b0 !== 5)) {
                                    if (!mseAppendQueueByStream[st]) mseAppendQueueByStream[st] = [];
                                    mseAppendQueueByStream[st].push({ nal: payload, key: false });
                                    if (mseAppendQueueByStream[st].length > 120) mseAppendQueueByStream[st].shift();
                                } else {
                                    appendMSEFragment(st, payload, b0 === 5);
                                }
                            } else if (videoDecodersByStream[st]) {
                                const withStart = new Uint8Array(START_CODE.length + payload.length);
                                withStart.set(START_CODE, 0); withStart.set(payload, START_CODE.length);
                                const frameIntervalUs = 1000000 / 30;
                                const ts = (lastVideoTimeByStream[st] || 0) + frameIntervalUs;
                                lastVideoTimeByStream[st] = ts;
                                decodeAndDrawH264ForStream(st, withStart, ts / 1000);
                            } else {
                                if (!msePendingNalsByStream[st]) msePendingNalsByStream[st] = [];
                                var q = msePendingNalsByStream[st];
                                q.push({ nal: payload, isKeyframe: b0 === 5 }); if (q.length > 60) q.shift();
                            }
                        } else {
                            if (!videoStreamDebug[st]) videoStreamDebug[st] = {};
                            videoStreamDebug[st].lastNal = 'type=' + b0;
                        }
                    } else if ((b0 === 28 || b0 === 29) && payload.length >= 3) {
                        const fuHeader = payload[1];
                        const realType = fuHeader & 0x1F;
                        const s = (fuHeader & 0x80) !== 0;
                        const e = (fuHeader & 0x40) !== 0;
                        const nalHeader = (payload[0] & 0xE0) | realType;
                        const fragment = payload.slice(2);
                        if (!window.h264FUABufferByStream) window.h264FUABufferByStream = {};
                        let buf = window.h264FUABufferByStream[st];
                        if (s) buf = { nalHeader: nalHeader, chunks: [fragment] };
                        else if (buf) buf.chunks.push(fragment);
                        if (e && buf) {
                            let len = 0; for (const c of buf.chunks) len += c.length;
                            const full = new Uint8Array(1 + len); full[0] = buf.nalHeader;
                            let off = 1; for (const c of buf.chunks) { full.set(c, off); off += c.length; }
                            if (realType === 7) {
                                if (!h264SPSByStream[st] || full.length > h264SPSByStream[st].length) h264SPSByStream[st] = full;
                                if (!mseSPSLoggedByStream[st]) { mseSPSLoggedByStream[st] = true; console.debug('[MSE-debug] SPS æ”¶åˆ°(FU-A)', st, 'len=', full.length); }
                                setVideoStreamStatus(st, 'å·²æ”¶ SPS (FU-A ' + full.length + 'B) | ' + getVideoStreamStatusLine(st), false);
                                initVideoDecoderIfReadyForStream(st);
                            } else if (realType === 8) {
                                if (!h264PPSByStream[st] || full.length > h264PPSByStream[st].length) h264PPSByStream[st] = full;
                                if (!msePPSLoggedByStream[st]) { msePPSLoggedByStream[st] = true; console.debug('[MSE-debug] PPS æ”¶åˆ°(FU-A)', st, 'len=', full.length); }
                                setVideoStreamStatus(st, 'å·²æ”¶ PPS (FU-A ' + full.length + 'B) | ' + getVideoStreamStatusLine(st), false);
                                initVideoDecoderIfReadyForStream(st);
                            } else if (realType === 1 || realType === 5) {
                                initVideoDecoderIfReadyForStream(st);
                                if (mseSourceBufferByStream[st]) {
                                    var needKey = !mseHasAppendedKeyframeByStream[st];
                                    if (needKey && (realType !== 5)) {
                                        if (!mseAppendQueueByStream[st]) mseAppendQueueByStream[st] = [];
                                        mseAppendQueueByStream[st].push({ nal: full, key: false });
                                        if (mseAppendQueueByStream[st].length > 120) mseAppendQueueByStream[st].shift();
                                    } else {
                                        appendMSEFragment(st, full, realType === 5);
                                    }
                                } else if (videoDecodersByStream[st]) {
                                    const withStart = new Uint8Array(4 + full.length);
                                    withStart.set([0,0,0,1], 0); withStart.set(full, 4);
                                    const ts = (lastVideoTimeByStream[st] || 0) + 1000000/30;
                                    lastVideoTimeByStream[st] = ts;
                                    decodeAndDrawH264ForStream(st, withStart, ts/1000);
                                } else {
                                    if (!msePendingNalsByStream[st]) msePendingNalsByStream[st] = [];
                                    var q = msePendingNalsByStream[st];
                                    q.push({ nal: full, isKeyframe: realType === 5 }); if (q.length > 60) q.shift();
                                }
                            }
                            buf = null;
                        }
                        window.h264FUABufferByStream[st] = buf;
                    } else {
                        setVideoStreamStatus(st, 'æœªçŸ¥ NAL é¦–å­—èŠ‚ type=' + b0 + ' len=' + payload.length + ' | ' + getVideoStreamStatusLine(st), true);
                    }
                }
            } catch (e) {
                console.error('[MediaMonitor] handleRtpPayloadForStream', streamType, e);
                setVideoStreamStatus(streamType, 'å¤„ç†å¼‚å¸¸: ' + (e.message || e) + ' | ' + getVideoStreamStatusLine(streamType), true);
            }
        }
        
        // SIPæ¶ˆæ¯è·Ÿè¸ªåŠŸèƒ½
        let sipMessagesWebSocket = null;
        let sipMessagesList = [];
        let columnFilters = {};
        let selectedMessageId = null;
        let sipMessagesPaused = false; // è·Ÿè¸ªæ˜¯å¦æš‚åœ
        let sipMessagesShowRetransmissions = false; // æ˜¯å¦æ˜¾ç¤ºé‡ä¼ æ¶ˆæ¯ï¼ˆé»˜è®¤ä¸æ˜¾ç¤ºï¼‰
        let sipMessagesPollIntervalId = null; // è½®è¯¢å®šæ—¶å™¨ï¼Œè¡¥å…¨ WebSocket å»¶è¿Ÿ/æ¼æ¨çš„æ¶ˆæ¯ï¼ˆå¦‚ re-INVITE 200 çš„ ACK FWDï¼‰
        let sipMessagesUserScrolled = false; // è·Ÿè¸ªç”¨æˆ·æ˜¯å¦æ‰‹åŠ¨æ»šåŠ¨è¿‡
        let sipMessagesAutoScrollTimeout = null; // è‡ªåŠ¨æ»šåŠ¨å®šæ—¶å™¨ï¼Œç”¨äºé˜²æŠ–
        
        // åˆå§‹åŒ–åˆ—å®½è°ƒæ•´åŠŸèƒ½
        function initColumnResize() {
            const table = document.getElementById('sip-messages-table');
            if (!table) return;
            
            const headers = table.querySelectorAll('thead th');
            let isResizing = false;
            let currentHeader = null;
            let startX = 0;
            let startWidth = 0;
            
            // ä» localStorage æ¢å¤åˆ—å®½
            const savedWidths = JSON.parse(localStorage.getItem('sip-messages-column-widths') || '{}');
            headers.forEach((header, index) => {
                const columnName = header.getAttribute('data-column');
                if (savedWidths[columnName]) {
                    header.style.width = savedWidths[columnName] + 'px';
                }
            });
            
            headers.forEach((header, index) => {
                const handle = header.querySelector('.resize-handle');
                if (!handle) return;
                
                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    isResizing = true;
                    currentHeader = header;
                    startX = e.clientX;
                    startWidth = header.offsetWidth;
                    header.classList.add('resizing');
                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';
                });
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing || !currentHeader) return;
                
                const diff = e.clientX - startX;
                const newWidth = Math.max(80, startWidth + diff); // æœ€å°å®½åº¦ 80px
                currentHeader.style.width = newWidth + 'px';
                
                // ä¿å­˜åˆ—å®½åˆ° localStorage
                const columnName = currentHeader.getAttribute('data-column');
                if (columnName) {
                    const savedWidths = JSON.parse(localStorage.getItem('sip-messages-column-widths') || '{}');
                    savedWidths[columnName] = newWidth;
                    localStorage.setItem('sip-messages-column-widths', JSON.stringify(savedWidths));
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    if (currentHeader) {
                        currentHeader.classList.remove('resizing');
                    }
                    currentHeader = null;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }
        
        function initSipMessages() {
            // åˆå§‹åŒ–åˆ—å®½è°ƒæ•´åŠŸèƒ½
            initColumnResize();
            
            const clearBtn = document.getElementById('sip-messages-clear-btn');
            const refreshBtn = document.getElementById('sip-messages-refresh-btn');
            const pauseBtn = document.getElementById('sip-messages-pause-btn');
            const closeModalBtn = document.getElementById('sip-message-detail-close');
            const modal = document.getElementById('sip-message-detail-modal');
            
            // æ¸…ç©ºæŒ‰é’®
            clearBtn.addEventListener('click', () => {
                if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰SIPæ¶ˆæ¯è®°å½•å—ï¼Ÿ')) {
                    clearSipMessages();
                }
            });
            
            // åˆ·æ–°æŒ‰é’®
            refreshBtn.addEventListener('click', () => {
                loadSipMessages();
            });
            
            // æ˜¾ç¤ºé‡ä¼ æ¶ˆæ¯å¤é€‰æ¡†
            const showRetransmissionsCheckbox = document.getElementById('sip-messages-show-retransmissions');
            if (showRetransmissionsCheckbox) {
                showRetransmissionsCheckbox.addEventListener('change', (e) => {
                    sipMessagesShowRetransmissions = e.target.checked;
                    console.log('[SIPMessages] æ˜¾ç¤ºé‡ä¼ æ¶ˆæ¯:', sipMessagesShowRetransmissions);
                    updateSipMessagesDisplay();
                });
            }
            
            // æš‚åœ/æ¢å¤è·Ÿè¸ªæŒ‰é’®
            pauseBtn.addEventListener('click', () => {
                sipMessagesPaused = !sipMessagesPaused;
                if (sipMessagesPaused) {
                    pauseBtn.textContent = 'æ¢å¤è·Ÿè¸ª';
                    pauseBtn.classList.add('paused');
                    console.log('[SIPMessages] è·Ÿè¸ªå·²æš‚åœ');
                    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯æ˜¾ç¤ºæš‚åœçŠ¶æ€
                    const statsSpan = document.getElementById('sip-messages-stats');
                    if (statsSpan) {
                        const currentText = statsSpan.textContent;
                        statsSpan.textContent = currentText + ' [å·²æš‚åœ]';
                        statsSpan.style.color = '#ff9800';
                    }
                } else {
                    pauseBtn.textContent = 'æš‚åœè·Ÿè¸ª';
                    pauseBtn.classList.remove('paused');
                    console.log('[SIPMessages] è·Ÿè¸ªå·²æ¢å¤');
                    // æ¢å¤ç»Ÿè®¡ä¿¡æ¯æ˜¾ç¤º
                    const statsSpan = document.getElementById('sip-messages-stats');
                    if (statsSpan) {
                        statsSpan.style.color = '';
                    }
                    // æ¢å¤åç«‹å³åŠ è½½ä¸€æ¬¡æœ€æ–°æ¶ˆæ¯
                    loadSipMessages();
                }
            });
            
            // å…³é—­å¯¹è¯æ¡†
            closeModalBtn.addEventListener('click', () => {
                modal.style.display = 'none';
            });
            
            // ç‚¹å‡»å¯¹è¯æ¡†å¤–éƒ¨å…³é—­
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            });
            
            // åˆå§‹åŒ–åˆ—è¿‡æ»¤
            document.querySelectorAll('.column-filter').forEach(input => {
                input.addEventListener('input', (e) => {
                    const column = e.target.dataset.column;
                    const value = e.target.value.trim();
                    if (value) {
                        columnFilters[column] = value;
                    } else {
                        delete columnFilters[column];
                    }
                    updateSipMessagesDisplay();
                });
            });
            
            // è¿æ¥WebSocketæ¥æ”¶å®æ—¶æ¶ˆæ¯
            connectSipMessagesWebSocket();
            
            // åˆå§‹åŠ è½½
            loadSipMessages();
            
            // åˆå§‹åŒ–æ»šåŠ¨äº‹ä»¶ç›‘å¬å™¨
            const scrollWrapper = document.querySelector('.sip-messages-table-scroll-wrapper');
            if (scrollWrapper) {
                scrollWrapper.addEventListener('scroll', handleSipMessagesScroll);
            }
        }
        
        // åŠ è½½SIPæ¶ˆæ¯åˆ—è¡¨
        function loadSipMessages() {
            const params = new URLSearchParams();
            params.append('action', 'list');
            params.append('limit', '2000');  // å¢åŠ åˆ° 2000ï¼Œç¡®ä¿ BYE 200 FWD ç­‰æ¶ˆæ¯ä¸è¢«æˆªæ‰
            params.append('offset', '0');
            
            // æ·»åŠ è¿‡æ»¤æ¡ä»¶
            Object.keys(columnFilters).forEach(key => {
                params.append(key, columnFilters[key]);
            });
            
            fetch(`/api/sip-messages?${params.toString()}`, {
                method: 'GET',
                credentials: 'include'
            })
                .then(response => {
                    if (response.redirected || response.status === 302) {
                        throw new Error('éœ€è¦ç™»å½•ï¼Œè¯·åˆ·æ–°é¡µé¢');
                    }
                    if (!response.ok) {
                        throw new Error(`HTTPé”™è¯¯: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        console.log('[SIPMessages] åŠ è½½æˆåŠŸï¼Œæ”¶åˆ°', data.records?.length || 0, 'æ¡æ¶ˆæ¯');
                        // åˆå¹¶è€Œä¸æ˜¯æ›¿æ¢ï¼šä¿ç•™ WebSocket æ¨é€çš„æœ€æ–°æ¶ˆæ¯ï¼Œé¿å…æœ€åä¸€æ¡æ¶ˆæ¯ä¸¢å¤±
                        const newRecords = data.records || [];
                        // æŒ‰ ID åˆå¹¶ï¼šä¿ç•™ ID æ›´å¤§çš„æ¶ˆæ¯ï¼ˆæ›´æ–°çš„ï¼‰
                        const mergedMap = new Map();
                        // å…ˆæ·»åŠ ç°æœ‰æ¶ˆæ¯ï¼ˆWebSocket æ¨é€çš„ï¼Œå¯èƒ½æ›´æ–°ï¼‰
                        sipMessagesList.forEach(msg => {
                            mergedMap.set(msg.id, msg);
                        });
                        // å†æ·»åŠ åç«¯è¿”å›çš„æ¶ˆæ¯ï¼Œå¦‚æœ ID ä¸å­˜åœ¨æˆ–æ—¶é—´æˆ³æ›´æ–°åˆ™è¦†ç›–
                        newRecords.forEach(record => {
                            const existing = mergedMap.get(record.id);
                            if (!existing || (record.timestamp && existing.timestamp && record.timestamp > existing.timestamp)) {
                                mergedMap.set(record.id, record);
                            }
                        });
                        sipMessagesList = Array.from(mergedMap.values());
                        // æŒ‰ ID æ’åºï¼ˆID è¶Šå¤§è¶Šæ–°ï¼‰ï¼Œç¡®ä¿æ•°ç»„é¡ºåºæ­£ç¡®
                        sipMessagesList.sort((a, b) => (a.id || 0) - (b.id || 0));
                        // é™åˆ¶åˆ—è¡¨å¤§å°ï¼ˆä¿ç•™æœ€æ–°çš„ï¼ŒID æœ€å¤§çš„ 2000 æ¡ï¼‰
                        if (sipMessagesList.length > 2000) {
                            sipMessagesList = sipMessagesList.slice(-2000);
                        }
                        updateSipMessagesStats(data.stats || {});
                        updateSipMessagesDisplay();
                    } else {
                        console.error('[SIPMessages] åŠ è½½å¤±è´¥:', data.message);
                    }
                })
                .catch(error => {
                    console.error('[SIPMessages] åŠ è½½é”™è¯¯:', error);
                });
        }
        
        // æ¸…ç©ºSIPæ¶ˆæ¯
        function clearSipMessages() {
            fetch('/api/sip-messages?action=clear', {
                method: 'GET',
                credentials: 'include'
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        sipMessagesList = [];
                        updateSipMessagesDisplay();
                        updateSipMessagesStats({ total: 0 });
                    } else {
                        alert('æ¸…ç©ºå¤±è´¥: ' + data.message);
                    }
                })
                .catch(error => {
                    console.error('[SIPMessages] æ¸…ç©ºé”™è¯¯:', error);
                });
        }
        
        // è¿æ¥WebSocketæ¥æ”¶å®æ—¶SIPæ¶ˆæ¯
        function connectSipMessagesWebSocket() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const httpPort = window.location.port ? parseInt(window.location.port) : 
                             (window.location.protocol === 'https:' ? 443 : 80);
            
            // å¦‚æœé€šè¿‡ Cloudflare éš§é“è®¿é—®ï¼ˆtrycloudflare.comï¼‰ï¼ŒWebSocket ä½¿ç”¨ç›¸åŒç«¯å£ï¼ˆHTTP å‡çº§ï¼‰
            // å¦åˆ™ä½¿ç”¨ç«¯å£ + 1ï¼ˆç‹¬ç«‹ WebSocket æœåŠ¡å™¨ï¼‰
            const isCloudflareTunnel = window.location.hostname.includes('trycloudflare.com');
            const wsPort = isCloudflareTunnel ? httpPort : ((httpPort === 80 || httpPort === 443) ? 8889 : (httpPort + 1));
            const wsUrl = `${wsProtocol}//${window.location.hostname}:${wsPort}/ws/sip-messages`;
            
            console.log('[SIPMessages] è¿æ¥WebSocket:', wsUrl, 'isCloudflareTunnel:', isCloudflareTunnel);
            sipMessagesWebSocket = new WebSocket(wsUrl);
            
            sipMessagesWebSocket.onopen = () => {
                console.log('[SIPMessages] WebSocketè¿æ¥å·²å»ºç«‹');
                // è¿æ¥æˆåŠŸåï¼Œç«‹å³åŠ è½½ä¸€æ¬¡æ¶ˆæ¯åˆ—è¡¨ï¼ˆç¡®ä¿èƒ½çœ‹åˆ°å†å²æ¶ˆæ¯ï¼‰
                loadSipMessages();
            };
            
            sipMessagesWebSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log('[SIPMessages] æ”¶åˆ°æ¶ˆæ¯:', data);
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç³»ç»Ÿæ¶ˆæ¯
                    if (data.type && data.type !== 'connected') {
                        if (data.type === 'connected') {
                            console.log('[SIPMessages]', data.message);
                        }
                        return;
                    }
                    
                    // å¦‚æœæš‚åœè·Ÿè¸ªï¼Œå¿½ç•¥æ–°æ¶ˆæ¯
                    if (sipMessagesPaused) {
                        console.log('[SIPMessages] è·Ÿè¸ªå·²æš‚åœï¼Œå¿½ç•¥æ–°æ¶ˆæ¯:', data.id || 'unknown');
                        return;
                    }
                    
                    // è¿™æ˜¯å®é™…çš„SIPæ¶ˆæ¯è®°å½•
                    if (data.id) {
                        console.log('[SIPMessages] æ”¶åˆ°SIPæ¶ˆæ¯è®°å½•ï¼ŒID:', data.id, 'æ–¹å‘:', data.direction, 'æ–¹æ³•:', data.method || data.status_code, 'æ—¶é—´æˆ³:', data.timestamp);
                        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆé¿å…é‡å¤ï¼‰
                        const exists = sipMessagesList.find(m => m.id === data.id);
                        if (!exists) {
                            sipMessagesList.push(data);
                            console.log('[SIPMessages] æ·»åŠ åˆ°åˆ—è¡¨ï¼Œå½“å‰æ€»æ•°:', sipMessagesList.length, 'æ¶ˆæ¯ID:', data.id);
                            // é™åˆ¶åˆ—è¡¨å¤§å°ï¼ˆä¿ç•™æœ€è¿‘2000ä¸ªï¼Œä¸ loadSipMessages çš„ limit ä¿æŒä¸€è‡´ï¼‰
                            if (sipMessagesList.length > 2000) {
                                sipMessagesList.shift();
                            }
                            // ç«‹å³æ›´æ–°æ˜¾ç¤ºï¼Œé¿å…å»¶è¿Ÿå¯¼è‡´æ¶ˆæ¯ä¸¢å¤±
                            updateSipMessagesDisplay();
                            console.log('[SIPMessages] æ˜¾ç¤ºå·²æ›´æ–°ï¼Œåˆ—è¡¨ä¸­çš„æ¶ˆæ¯IDèŒƒå›´:', 
                                sipMessagesList.length > 0 ? `${sipMessagesList[0].id}-${sipMessagesList[sipMessagesList.length-1].id}` : 'empty');
                        } else {
                            console.log('[SIPMessages] æ¶ˆæ¯å·²å­˜åœ¨ï¼Œè·³è¿‡:', data.id);
                        }
                    } else {
                        console.warn('[SIPMessages] æ”¶åˆ°æ¶ˆæ¯ä½†æ²¡æœ‰ID:', data);
                    }
                } catch (e) {
                    console.error('[SIPMessages] è§£ææ¶ˆæ¯å¤±è´¥:', e, 'åŸå§‹æ•°æ®:', event.data);
                }
            };
            
            sipMessagesWebSocket.onerror = (error) => {
                console.error('[SIPMessages] WebSocketé”™è¯¯:', error);
                console.error('[SIPMessages] WebSocket URL:', wsUrl);
                console.error('[SIPMessages] å½“å‰é¡µé¢URL:', window.location.href);
                
                // å¦‚æœæ˜¯é€šè¿‡ Cloudflare éš§é“è®¿é—®ï¼Œæç¤º WebSocket ä¸å¯ç”¨
                if (window.location.hostname.includes('trycloudflare.com')) {
                    console.warn('[SIPMessages] é€šè¿‡ Cloudflare ä¸´æ—¶éš§é“è®¿é—®æ—¶ï¼ŒWebSocket åŠŸèƒ½ä¸å¯ç”¨');
                    console.warn('[SIPMessages] è¯·ä½¿ç”¨ HTTP API è·å– SIP æ¶ˆæ¯ï¼ˆç‚¹å‡»"åˆ·æ–°"æŒ‰é’®ï¼‰');
                    // æ˜¾ç¤ºæç¤ºä¿¡æ¯
                    const statsDiv = document.getElementById('sip-messages-stats');
                    if (statsDiv) {
                        statsDiv.innerHTML = '<div style="color: orange; padding: 10px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; margin: 10px 0;">âš ï¸ é€šè¿‡ Cloudflare ä¸´æ—¶éš§é“è®¿é—®æ—¶ï¼ŒWebSocket å®æ—¶æ¨é€ä¸å¯ç”¨ã€‚è¯·ä½¿ç”¨"åˆ·æ–°"æŒ‰é’®æ‰‹åŠ¨è·å– SIP æ¶ˆæ¯ã€‚</div>';
                    }
                }
            };
            
            sipMessagesWebSocket.onclose = (event) => {
                console.log('[SIPMessages] WebSocketè¿æ¥å·²å…³é—­', 'code:', event.code, 'reason:', event.reason);
                sipMessagesWebSocket = null;
                
                // å¦‚æœæ˜¯é€šè¿‡ Cloudflare éš§é“è®¿é—®ï¼Œä¸è‡ªåŠ¨é‡è¿
                if (window.location.hostname.includes('trycloudflare.com')) {
                    console.log('[SIPMessages] é€šè¿‡ Cloudflare ä¸´æ—¶éš§é“è®¿é—®ï¼Œä¸è‡ªåŠ¨é‡è¿ WebSocket');
                    return;
                }
                
                // å¦‚æœè¿æ¥æ„å¤–å…³é—­ï¼Œå°è¯•é‡è¿ï¼ˆå»¶è¿Ÿ3ç§’ï¼‰
                if (event.code !== 1000) {
                    setTimeout(() => {
                        connectSipMessagesWebSocket();
                    }, 3000);
                }
            };
        }
        
        // å¤„ç†ç”¨æˆ·æ‰‹åŠ¨æ»šåŠ¨äº‹ä»¶
        function handleSipMessagesScroll() {
            const scrollWrapper = document.querySelector('.sip-messages-table-scroll-wrapper');
            if (!scrollWrapper) return;
            
            // æ£€æŸ¥æ˜¯å¦æ¥è¿‘åº•éƒ¨ï¼ˆè·ç¦»åº•éƒ¨å°äº50pxï¼‰
            const isNearBottom = scrollWrapper.scrollHeight - scrollWrapper.scrollTop - scrollWrapper.clientHeight < 50;
            
            // å¦‚æœç”¨æˆ·æ»šåŠ¨åˆ°æ¥è¿‘åº•éƒ¨ï¼Œé‡ç½®æ‰‹åŠ¨æ»šåŠ¨æ ‡å¿—ï¼Œå…è®¸åç»­è‡ªåŠ¨æ»šåŠ¨
            if (isNearBottom) {
                sipMessagesUserScrolled = false;
            } else {
                // å¦‚æœç”¨æˆ·å‘ä¸Šæ»šåŠ¨ï¼Œæ ‡è®°ä¸ºç”¨æˆ·æ‰‹åŠ¨æ»šåŠ¨
                sipMessagesUserScrolled = true;
            }
        }
        
        // æ›´æ–°SIPæ¶ˆæ¯è¡¨æ ¼æ˜¾ç¤º
        function updateSipMessagesDisplay() {
            const tbody = document.getElementById('sip-messages-tbody');
            if (!tbody) {
                return;
            }
            
            // è°ƒè¯•ï¼šè®°å½•æ›´æ–°å‰çš„åˆ—è¡¨çŠ¶æ€
            if (sipMessagesList.length > 0) {
                const lastMsg = sipMessagesList[sipMessagesList.length - 1];
                const ackFwdCount = sipMessagesList.filter(m => (m.method === 'ACK' || m.status_code === 'ACK') && m.direction === 'FWD').length;
                const maxId = Math.max(...sipMessagesList.map(m => m.id || 0));
                console.log('[SIPMessages] æ›´æ–°æ˜¾ç¤ºï¼Œåˆ—è¡¨æ€»æ•°:', sipMessagesList.length, 'ACK FWDæ•°é‡:', ackFwdCount, 'æœ€å¤§ID:', maxId, 'æ•°ç»„æœ€åä¸€æ¡ID:', lastMsg.id);
            }
            
            // åº”ç”¨é»˜è®¤è¿‡æ»¤ï¼šé»˜è®¤ä¸æ˜¾ç¤ºé‡ä¼ æ¶ˆæ¯
            let filteredMessages = sipMessagesList;
            if (!sipMessagesShowRetransmissions) {
                filteredMessages = filteredMessages.filter(msg => !msg.is_retransmission);
            }
            
            // åº”ç”¨åˆ—è¿‡æ»¤
            if (Object.keys(columnFilters).length > 0) {
                filteredMessages = filteredMessages.filter(msg => {
                    for (const [column, filterValue] of Object.entries(columnFilters)) {
                        let msgValue = '';
                        // å¤„ç†è™šæ‹Ÿåˆ—ï¼šUDPåœ°å€å’ŒSIPåœ°å€
                        if (column === 'udp_addr') {
                            // UDP IPå±‚åœ°å€ï¼šæºIP:ç«¯å£ â†’ ç›®æ ‡IP:ç«¯å£
                            msgValue = `${msg.src_ip || ''}:${msg.src_port || ''} â†’ ${msg.dst_ip || ''}:${msg.dst_port || ''}`.toLowerCase();
                        } else if (column === 'sip_addr') {
                            // SIPåè®®å±‚åœ°å€ï¼šæºIP:ç«¯å£ â†’ ç›®æ ‡IP:ç«¯å£
                            const srcSip = msg.src_ip_nat || msg.src_ip || '';
                            const srcPortSip = msg.src_port_nat || msg.src_port || '';
                            const dstSip = msg.dst_ip_nat || msg.dst_ip || '';
                            const dstPortSip = msg.dst_port_nat || msg.dst_port || '';
                            msgValue = `${srcSip}${srcPortSip ? ':' + srcPortSip : ''} â†’ ${dstSip}${dstPortSip ? ':' + dstPortSip : ''}`.toLowerCase();
                        } else {
                            // æ™®é€šåˆ—ï¼šç›´æ¥ä½¿ç”¨æ¶ˆæ¯å¯¹è±¡çš„å­—æ®µ
                            msgValue = String(msg[column] || '').toLowerCase();
                        }
                        if (!msgValue.includes(filterValue.toLowerCase())) {
                            return false;
                        }
                    }
                    return true;
                });
            }
            
            // æŒ‰æ—¶é—´æˆ³å’ŒIDæ’åºï¼ˆä»æ—§åˆ°æ–°ï¼Œä¾¿äºæŸ¥çœ‹å¯¹è¯æµç¨‹ï¼‰
            // ç¡®ä¿æ—¶é—´æˆ³ç›¸åŒæˆ–æ¥è¿‘æ—¶ï¼ŒID å¤§çš„æ’åœ¨åé¢ï¼ˆæ›´æ–°çš„æ¶ˆæ¯ï¼‰
            filteredMessages = filteredMessages.slice().sort((a, b) => {
                // å…ˆæŒ‰æ—¶é—´æˆ³æ’åº
                const tsDiff = (a.timestamp || 0) - (b.timestamp || 0);
                if (Math.abs(tsDiff) > 0.001) {  // æ—¶é—´æˆ³å·®å¼‚å¤§äº 1msï¼ŒæŒ‰æ—¶é—´æˆ³æ’åº
                    return tsDiff;
                }
                // æ—¶é—´æˆ³ç›¸åŒæˆ–éå¸¸æ¥è¿‘ï¼ˆ1mså†…ï¼‰ï¼ŒæŒ‰IDæ’åºï¼ˆIDè¶Šå¤§è¶Šæ–°ï¼‰
                return (a.id || 0) - (b.id || 0);
            });
            
            // è°ƒè¯•ï¼šè®°å½•æ’åºåçš„çŠ¶æ€
            if (filteredMessages.length > 0) {
                const sortedLastMsg = filteredMessages[filteredMessages.length - 1];
                const ackFwdInFiltered = filteredMessages.filter(m => (m.method === 'ACK' || m.status_code === 'ACK') && m.direction === 'FWD');
                console.log('[SIPMessages] æ’åºåï¼Œæœ€åä¸€æ¡æ¶ˆæ¯ID:', sortedLastMsg.id, 'æ–¹å‘:', sortedLastMsg.direction, 'æ–¹æ³•:', sortedLastMsg.method || sortedLastMsg.status_code, 'ACK FWDæ•°é‡:', ackFwdInFiltered.length);
            }
            
            tbody.innerHTML = '';
            
            if (filteredMessages.length === 0) {
                tbody.innerHTML = '<tr><td colspan="10" style="text-align: center; color: #858585; padding: 20px;">æš‚æ— æ¶ˆæ¯</td></tr>';
                // å³ä½¿æ²¡æœ‰æ¶ˆæ¯ï¼Œä¹Ÿæ·»åŠ ç©ºç™½è¡Œä¿æŒå¸ƒå±€ä¸€è‡´
                const spacerRow = document.createElement('tr');
                spacerRow.className = 'sip-messages-spacer-row';
                spacerRow.innerHTML = '<td colspan="10"></td>';
                tbody.appendChild(spacerRow);
                return;
            }
            
            // æ˜¾ç¤ºæ¶ˆæ¯ï¼ˆä»æ—§åˆ°æ–°ï¼Œä¾¿äºæŸ¥çœ‹å¯¹è¯æµç¨‹ï¼‰
            // è°ƒè¯•ï¼šè®°å½•è¦æ˜¾ç¤ºçš„æ¶ˆæ¯æ•°é‡
            const ackFwdInFiltered = filteredMessages.filter(m => (m.method === 'ACK' || m.status_code === 'ACK') && m.direction === 'FWD');
            if (ackFwdInFiltered.length > 0) {
                console.log('[SIPMessages] è¿‡æ»¤ååˆ—è¡¨ä¸­çš„ACK FWDæ•°é‡:', ackFwdInFiltered.length, 'IDåˆ—è¡¨:', ackFwdInFiltered.map(m => m.id));
            }
            
            filteredMessages.forEach(msg => {
                const row = document.createElement('tr');
                row.dataset.id = msg.id;
                if (selectedMessageId === msg.id) {
                    row.classList.add('selected');
                }
                
                // æ–¹å‘é¢œè‰²
                const directionColor = {
                    'RX': '#4ec9b0',
                    'TX': '#569cd6',
                    'FWD': '#ce9178'
                }[msg.direction] || '#d4d4d4';
                
                // æ¶ˆæ¯ç±»å‹æ˜¾ç¤ºï¼šå¦‚æœæ˜¯é‡ä¼ ï¼ŒåŠ ä¸Šæ ‡è®°
                const methodText = msg.method || msg.status_code || '';
                const methodDisplay = msg.is_retransmission ? `${methodText} (é‡ä¼ )` : methodText;
                
                row.innerHTML = `
                    <td>${escapeHtml(msg.time_str || '')}</td>
                    <td>${escapeHtml(methodDisplay)}</td>
                    <td style="color: ${directionColor};">${escapeHtml(msg.direction || '')}</td>
                    <td>${escapeHtml(msg.registered_user || '')}</td>
                    <td>${escapeHtml(msg.from_user || '')}</td>
                    <td>${escapeHtml(msg.callee || msg.to_user || '')}</td>
                    <td title="UDP IPå±‚åœ°å€">${escapeHtml(msg.src_ip || '')}:${escapeHtml(String(msg.src_port || ''))} â†’ ${escapeHtml(msg.dst_ip || '')}:${escapeHtml(String(msg.dst_port || ''))}</td>
                    <td title="SIPåè®®å±‚åœ°å€">${escapeHtml(msg.src_ip_nat || msg.src_ip || '')}${(msg.src_ip_nat || msg.src_ip) && (msg.src_port_nat || msg.src_port) ? ':' + escapeHtml(String(msg.src_port_nat || msg.src_port || '')) : ''} â†’ ${escapeHtml(msg.dst_ip_nat || msg.dst_ip || '')}${(msg.dst_ip_nat || msg.dst_ip) && (msg.dst_port_nat || msg.dst_port) ? ':' + escapeHtml(String(msg.dst_port_nat || msg.dst_port || '')) : ''}</td>
                    <td title="${escapeHtml(msg.call_id || '')}">${escapeHtml((msg.call_id || '').substring(0, 20))}${(msg.call_id || '').length > 20 ? '...' : ''}</td>
                    <td title="${escapeHtml(msg.sdp_info || '')}">${escapeHtml(msg.sdp_info || '')}</td>
                `;
                
                // åŒå‡»æŸ¥çœ‹æ¶ˆæ¯è¯¦æƒ…
                row.addEventListener('dblclick', () => {
                    showMessageDetail(msg.id);
                });
                
                // å•å‡»é€‰ä¸­
                row.addEventListener('click', () => {
                    document.querySelectorAll('#sip-messages-tbody tr').forEach(r => r.classList.remove('selected'));
                    row.classList.add('selected');
                    selectedMessageId = msg.id;
                });
                
                tbody.appendChild(row);
            });
            
            // åœ¨è¡¨æ ¼åº•éƒ¨æ·»åŠ ä¸€ä¸ªç©ºç™½è¡Œï¼Œç¡®ä¿æœ€åä¸€æ¡æ¶ˆæ¯å®Œå…¨å¯è§
            const spacerRow = document.createElement('tr');
            spacerRow.className = 'sip-messages-spacer-row';
            spacerRow.innerHTML = '<td colspan="10"></td>';
            tbody.appendChild(spacerRow);
            
            // é»˜è®¤è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨ï¼ˆæ˜¾ç¤ºæœ€æ–°æ¶ˆæ¯ï¼‰ï¼Œä½†åªåœ¨ç”¨æˆ·æ²¡æœ‰æ‰‹åŠ¨æ»šåŠ¨æ—¶æ‰æ»šåŠ¨
            // ä½¿ç”¨å†…å±‚æ»šåŠ¨å®¹å™¨è¿›è¡Œæ»šåŠ¨æ§åˆ¶
            const scrollWrapper = document.querySelector('.sip-messages-table-scroll-wrapper');
            if (scrollWrapper && tbody) {
                // æ¸…é™¤ä¹‹å‰çš„è‡ªåŠ¨æ»šåŠ¨å®šæ—¶å™¨
                if (sipMessagesAutoScrollTimeout) {
                    clearTimeout(sipMessagesAutoScrollTimeout);
                }
                
                // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ‰‹åŠ¨æ»šåŠ¨è¿‡ï¼Œæˆ–è€…æ˜¯å¦æ¥è¿‘åº•éƒ¨ï¼ˆè·ç¦»åº•éƒ¨å°äº50pxæ—¶è®¤ä¸ºæ¥è¿‘åº•éƒ¨ï¼‰
                const isNearBottom = scrollWrapper.scrollHeight - scrollWrapper.scrollTop - scrollWrapper.clientHeight < 50;
                
                // åªåœ¨ç”¨æˆ·æ²¡æœ‰æ‰‹åŠ¨æ»šåŠ¨ï¼Œæˆ–è€…å·²ç»æ¥è¿‘åº•éƒ¨æ—¶ï¼Œæ‰è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
                if (!sipMessagesUserScrolled || isNearBottom) {
                    // ä½¿ç”¨é˜²æŠ–ï¼Œå»¶è¿Ÿæ‰§è¡Œæ»šåŠ¨ï¼Œé¿å…é¢‘ç¹è§¦å‘å¯¼è‡´è·³åŠ¨
                    sipMessagesAutoScrollTimeout = setTimeout(() => {
                        // ç­‰å¾… DOM æ›´æ–°å®Œæˆ
                        requestAnimationFrame(() => {
                            setTimeout(() => {
                                // ç®€å•ç›´æ¥åœ°æ»šåŠ¨åˆ°åº•éƒ¨
                                scrollWrapper.scrollTop = scrollWrapper.scrollHeight;
                                // å¦‚æœç”¨æˆ·æ¥è¿‘åº•éƒ¨ï¼Œé‡ç½®æ‰‹åŠ¨æ»šåŠ¨æ ‡å¿—ï¼Œå…è®¸åç»­è‡ªåŠ¨æ»šåŠ¨
                                if (isNearBottom) {
                                    sipMessagesUserScrolled = false;
                                }
                            }, 50);
                        });
                    }, 100);
                }
            }
        }
        
        // æ˜¾ç¤ºæ¶ˆæ¯è¯¦æƒ…
        function showMessageDetail(msgId) {
            fetch(`/api/sip-messages?action=get&id=${msgId}`, {
                method: 'GET',
                credentials: 'include'
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.record) {
                        const modal = document.getElementById('sip-message-detail-modal');
                        const content = document.getElementById('sip-message-detail-content');
                        content.textContent = data.record.full_message || 'æ— æ¶ˆæ¯å†…å®¹';
                        modal.style.display = 'block';
                    } else {
                        alert('è·å–æ¶ˆæ¯è¯¦æƒ…å¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'));
                    }
                })
                .catch(error => {
                    console.error('[SIPMessages] è·å–æ¶ˆæ¯è¯¦æƒ…é”™è¯¯:', error);
                    alert('è·å–æ¶ˆæ¯è¯¦æƒ…å¤±è´¥');
                });
        }
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateSipMessagesStats(stats) {
            const statsSpan = document.getElementById('sip-messages-stats');
            if (!statsSpan) {
                return;
            }
            
            // ä¿å­˜æš‚åœæ ‡è®°
            const pausedMark = statsSpan.textContent.includes('[å·²æš‚åœ]') ? ' [å·²æš‚åœ]' : '';
            
            if (stats.total !== undefined) {
                statsSpan.textContent = `æ€»è®¡: ${stats.total} | RX: ${stats.rx || 0} | TX: ${stats.tx || 0} | FWD: ${stats.fwd || 0}${pausedMark}`;
                // å¦‚æœæš‚åœï¼Œè®¾ç½®æ©™è‰²
                if (sipMessagesPaused) {
                    statsSpan.style.color = '#ff9800';
                } else {
                    statsSpan.style.color = '';
                }
            } else {
                // ä»APIè·å–ç»Ÿè®¡
                fetch('/api/sip-messages?action=stats', {
                    method: 'GET',
                    credentials: 'include'
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success && data.stats) {
                            const s = data.stats;
                            const pausedMark = sipMessagesPaused ? ' [å·²æš‚åœ]' : '';
                            statsSpan.textContent = `æ€»è®¡: ${s.total || 0} | RX: ${s.rx || 0} | TX: ${s.tx || 0} | FWD: ${s.fwd || 0}${pausedMark}`;
                            // å¦‚æœæš‚åœï¼Œè®¾ç½®æ©™è‰²
                            if (sipMessagesPaused) {
                                statsSpan.style.color = '#ff9800';
                            } else {
                                statsSpan.style.color = '';
                            }
                        }
                    })
                    .catch(error => {
                        console.error('è·å–ç»Ÿè®¡å¤±è´¥:', error);
                    });
            }
        }
        
        // æ›´æ–°å†å²è®°å½•æ˜¾ç¤º
        function updateHistoryDisplay() {
            const historyList = document.getElementById('history-list');
            
            if (commandHistoryDetails.length === 0) {
                historyList.innerHTML = '<p style="color: #858585; text-align: center; margin-top: 50px;">æš‚æ— å†å²è®°å½•</p>';
                return;
            }
            
            historyList.innerHTML = '';
            
            commandHistoryDetails.forEach((item, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'history-item';
                itemDiv.dataset.id = item.id;
                
                // æˆªå–è¾“å‡ºçš„å‰80ä¸ªå­—ç¬¦ä½œä¸ºé¢„è§ˆ
                const preview = item.output.split('\n')[0].substring(0, 80) + 
                               (item.output.length > 80 ? '...' : '');
                
                itemDiv.innerHTML = `
                    <div class="history-item-header">
                        <span class="history-item-command">${escapeHtml(item.command)}</span>
                        <span class="history-item-time">${item.timestamp}</span>
                    </div>
                    <div class="history-item-result">${escapeHtml(preview)}</div>
                `;
                
                itemDiv.addEventListener('click', () => {
                    // ç§»é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
                    document.querySelectorAll('.history-item').forEach(el => {
                        el.classList.remove('selected');
                    });
                    itemDiv.classList.add('selected');
                    
                    // åœ¨å†å²è¯¦æƒ…åŒºåŸŸæ˜¾ç¤ºå®Œæ•´ç»“æœ
                    const historyDetail = document.getElementById('history-detail');
                    historyDetail.classList.add('show');
                    historyDetail.innerHTML = `
                        <div class="output-entry">
                            <div class="output-time">[å†å²è®°å½•] ${item.timestamp}</div>
                            <div class="output-command">MML> ${escapeHtml(item.command)}</div>
                            <div class="output-${item.status}">${escapeHtml(item.output)}</div>
                        </div>
                    `;
                    
                    // æ»šåŠ¨åˆ°é¡¶éƒ¨
                    historyDetail.scrollTop = 0;
                });
                
                historyList.appendChild(itemDiv);
            });
        }
        
        // æ›´æ–°å†å²æŒ‰é’®çŠ¶æ€
        function updateHistoryButtons() {
            const prevBtn = document.getElementById('history-prev-btn');
            const nextBtn = document.getElementById('history-next-btn');
            
            prevBtn.disabled = historyIndex >= commandHistory.length - 1;
            nextBtn.disabled = historyIndex <= -1;
        }
        
        // å†å²å¯¼èˆª
        function initHistoryNavigation() {
            const prevBtn = document.getElementById('history-prev-btn');
            const nextBtn = document.getElementById('history-next-btn');
            const input = document.getElementById('command-input');
            
            // ä¸Šä¸€æ¡å‘½ä»¤
            prevBtn.addEventListener('click', () => {
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    input.value = commandHistory[historyIndex];
                    updateHistoryButtons();
                }
            });
            
            // ä¸‹ä¸€æ¡å‘½ä»¤
            nextBtn.addEventListener('click', () => {
                if (historyIndex > -1) {
                    historyIndex--;
                    if (historyIndex === -1) {
                        input.value = '';
                    } else {
                        input.value = commandHistory[historyIndex];
                    }
                    updateHistoryButtons();
                }
            });
            
            // é”®ç›˜å¿«æ·é”®ï¼šâ†‘ å’Œ â†“
            input.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    prevBtn.click();
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    nextBtn.click();
                }
            });
            
            // åˆå§‹çŠ¶æ€
            updateHistoryButtons();
        }
        
        // è·å–å½“å‰ç™»å½•ç”¨æˆ·ä¿¡æ¯
        async function loadUserInfo() {
            try {
                const response = await fetch('/api/check_auth');
                const data = await response.json();
                
                if (data.authenticated && data.username) {
                    document.getElementById('current-username').textContent = `ğŸ‘¤ ${data.username}`;
                } else {
                    // æœªç™»å½•ï¼Œè·³è½¬åˆ°ç™»å½•é¡µ
                    window.location.href = '/login.html';
                }
            } catch (error) {
                console.error('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', error);
            }
        }
        
        // å¤„ç†ç™»å‡º
        document.getElementById('logout-btn').addEventListener('click', async () => {
            if (confirm('ç¡®å®šè¦é€€å‡ºç™»å½•å—ï¼Ÿ')) {
                window.location.href = '/api/logout';
            }
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            loadUserInfo();
            loadCommandTree();
            connectWebSocket();
            initResizers();
            initAutocomplete();
            initParamForm();
            initOutputTabs();
            initHistoryNavigation();
            initSipMessages();
        });
    </script>
</body>
</html>

